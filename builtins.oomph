func __Bool_to_string(Bool self) -> Str:
    if self:
        return "true"
    return "false"

func __Str_find_first(Str self, Str substring) -> Optional[Int]:
    let result = __string_find_internal(self, substring)
    if result == -1:   # Currently it's difficult to have optionals in C code
        return null
    return result

func __Str_repeat(Str self, Int n) -> Str:
    # Square and multiply algorithm
    let result = ""
    let doubling = self
    while n > 0:
        if n mod 2 == 1:
            result = result + doubling
        n = (n / 2).floor()
        doubling = doubling + doubling
    return result

func __Str_remove_prefix(Str self, Str prefix) -> Optional[Str]:
    let result = __remove_prefix(self, prefix)
    if result == self and prefix != "":
        return null
    return result

func __Str_remove_suffix(Str self, Str suffix) -> Optional[Str]:
    let result = __remove_suffix(self, suffix)
    if result == self and suffix != "":
        return null
    return result

func __Str_starts_with(Str self, Str prefix) -> Bool:
    return (self.remove_prefix(prefix) != null)

func __Str_ends_with(Str self, Str suffix) -> Bool:
    return (self.remove_suffix(suffix) != null)

func __Str_contains(Str self, Str substring) -> Bool:
    return (self == "" and substring == "") or __string_from_start_to(self, substring) != self

# No need to use a third party library for this, lol
func __Str_left_pad(Str self, Int len, Str pad_char) -> Str:
    return pad_char.repeat(len - self.length()) + self

func __Str_right_pad(Str self, Int len, Str pad_char) -> Str:
    return self + pad_char.repeat(len - self.length())

func __Str_center_pad(Str self, Int len, Str pad_char) -> Str:
    let average = ((self.length() + len)/2).floor()
    return self.left_pad(average, pad_char).right_pad(len, pad_char)

func __Str_count(Str self, Str substring) -> Int:
    if substring == "":
        # Same as what Python does
        return self.length() + 1

    let count = 0
    while true:
        let before_substring = __string_from_start_to(self, substring)
        if before_substring == self:
            return count
        count = count + 1
        self = self.remove_prefix(before_substring).get().remove_prefix(substring).get()

func __Str_left_trim(Str self) -> Str:
    # TODO: all ascii whitespace?
    while self.starts_with(" ") or self.starts_with("\n"):  # TODO: all ascii whitespaces?
        # TODO: something like self = self.starts_with(" ").or_if_null_then(self)
        if self.starts_with(" "):
            self = self.remove_prefix(" ").get()
        if self.starts_with("\n"):
            self = self.remove_prefix("\n").get()
    return self

func __Str_right_trim(Str self) -> Str:
    # TODO: left_trim copy/pasta
    while self.ends_with(" ") or self.ends_with("\n"):
        if self.ends_with(" "):
            self = self.remove_suffix(" ").get()
        if self.ends_with("\n"):
            self = self.remove_suffix("\n").get()
    return self

func __Str_trim(Str self) -> Str:
    return self.left_trim().right_trim()

func __Str_replace(Str self, Str old, Str neww) -> Str:
    return self.split(old).join(neww)

func __Str_split(Str self, Str sep) -> List[Str]:
    if sep == "":
        # doesn't make much sense, but at least .split(s).join(s) will do nothing
        return [self]

    let result = []
    while true:
        let part = __string_from_start_to(self, sep)
        result.push(part)
        self = self.remove_prefix(part).get()
        if self == "":
            return result
        self = self.remove_prefix(sep).get()

func __List_Str_join(List[Str] self, Str sep) -> Str:
    if self == []:
        return ""

    let result = self.get(0)
    for let i = 1; i < self.length(); i = i+1:
        result = result + sep + self.get(i)
    return result
