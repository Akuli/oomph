func list_contains(List[Str] list, Str s) -> bool:
    foreach item of list:
        if item == s:
            return true
    return false

func starts_with_any(Str s, List[Str] prefixes) -> optional[Str]:
    foreach prefix of prefixes:
        if s.starts_with(prefix):
            return new optional[Str](prefix)
    return null[Str]

func get_simple_identifier(Str code) -> optional[Str]:
    # TODO: put this to stdlib
    let first_chars = new List[Str]()
    first_chars.push("a")
    first_chars.push("b")
    first_chars.push("c")
    first_chars.push("d")
    first_chars.push("e")
    first_chars.push("f")
    first_chars.push("g")
    first_chars.push("h")
    first_chars.push("i")
    first_chars.push("j")
    first_chars.push("k")
    first_chars.push("l")
    first_chars.push("m")
    first_chars.push("n")
    first_chars.push("o")
    first_chars.push("p")
    first_chars.push("q")
    first_chars.push("r")
    first_chars.push("s")
    first_chars.push("t")
    first_chars.push("u")
    first_chars.push("v")
    first_chars.push("w")
    first_chars.push("x")
    first_chars.push("y")
    first_chars.push("z")
    first_chars.push("A")
    first_chars.push("B")
    first_chars.push("C")
    first_chars.push("D")
    first_chars.push("E")
    first_chars.push("F")
    first_chars.push("G")
    first_chars.push("H")
    first_chars.push("I")
    first_chars.push("J")
    first_chars.push("K")
    first_chars.push("L")
    first_chars.push("M")
    first_chars.push("N")
    first_chars.push("O")
    first_chars.push("P")
    first_chars.push("Q")
    first_chars.push("R")
    first_chars.push("S")
    first_chars.push("T")
    first_chars.push("U")
    first_chars.push("V")
    first_chars.push("W")
    first_chars.push("X")
    first_chars.push("Y")
    first_chars.push("Z")
    first_chars.push("_")

    let continue_chars = new List[Str]()
    continue_chars.push_all(first_chars)
    for let i = 0; i <= 9; i = i+1:
        continue_chars.push(i.to_string())

    if not list_contains(first_chars, code.slice(0, 1)):
        return null[Str]

    let i = 1
    while list_contains(continue_chars, code.slice(i, i + 1)):
        i = i + 1
    return new optional[Str](code.slice(0, i))

# TODO: enums
class Token(Str type, Str value):
    meth matches(Str type, Str value) -> bool:
        return self.type == type and self.value == value

export func tokenize(Str code):
    let ops = new List[Str]()
    ops.push("(")
    ops.push(")")
    ops.push(":")
    ops.push("\n")

    let result = new List[Token]()
    while code != "":
        let id = get_simple_identifier(code)
        if id != null[Str]:
            if id.get() == "export" or id.get() == "func":
                result.push(new Token("keyword", id.get()))
            else:
                result.push(new Token("id", id.get()))

            code = code.slice(id.get().length(), code.length())
            continue

        let op = starts_with_any(code, ops)
        if op != null[Str]:
            result.push(new Token("op", op.get()))
            code = code.slice(op.get().length(), code.length())
            continue

        if code.starts_with(" "):
            if result.get(result.length() - 1).matches("op", "\n"):
                # Space after newline: indentation
                assert(result.length() != 0)  # TODO: error
                let indent_level = 0
                while code.slice(indent_level, indent_level + 1) == " ":
                    indent_level = indent_level + 1
                result.push(new Token("indent", code.slice(0, indent_level)))
                code = code.slice(indent_level, code.length())
            else:
                # Space to be ignored
                code = code.slice(1, code.length())
            continue

        if code.starts_with("\""):
            # TODO: escapes
            # TODO: error handling
            let content_length = code.slice(1, code.length()).find_first("\"").get()
            let token_length = content_length + 2
            result.push(new Token("string", code.slice(0, token_length)))
            code = code.slice(token_length, code.length())
            continue

        print(result)
        print("Invalid syntax: {code}")
        assert(false)  # TODO: error

    print("Success: {result}")
