import "ast.oomph" as ast
import "ir.oomph" as ir

class Converter(ir::Builtins builtins, List[ir::Instruction] code, int varname_counter):
    meth find_function(Str name) -> ir::BuiltinVariable:
        foreach var of self.builtins.get_variables():
            if var.name == name:
                return var
        assert(false)  # TODO: error

    meth create_var(ir::ObjectType type) -> ir::LocalVariable:
        self.varname_counter = self.varname_counter + 1
        return new ir::LocalVariable(type, self.varname_counter)

    meth do_expression(ast::Expression expr) -> ir::LocalVariable:
        switch expr:
            case ast::GetVar:
                print("getvar {expr}")
                assert(false)  # TODO
            case ast::StringConstant:
                let var = self.create_var(self.builtins.STR)
                self.code.push(new ir::Instruction(new ir::StringConstant(expr.value, var)))
            case ast::IntConstant:
                var = self.create_var(self.builtins.INT)
                self.code.push(new ir::Instruction(new ir::IntConstant(expr.value, var)))
            case ast::Call:
                print("call {expr}")
                assert(false)  # TODO

        return var

    meth stringify(ir::LocalVariable var) -> ir::LocalVariable:
        let result = self.create_var(self.builtins.STR)
        self.code.push(new ir::Instruction(new ir::MethodCall(var, "to_string", new List[ir::LocalVariable](), new optional[ir::LocalVariable](result))))
        return result

    meth do_statement(ast::Call call):
        let f = call.function
        switch f:
            # Currently, functions must be variables
            case ast::GetVar:
                let func_var = self.find_function(f.varname)
            case ast::Call:
                assert(false)  # TODO: error
            case ast::IntConstant:
                assert(false)  # TODO: error
            case ast::StringConstant:
                assert(false)  # TODO: error

        let argvars = new List[ir::LocalVariable]()
        foreach arg of call.args:
            let expr = self.do_expression(arg)
            if func_var == self.builtins.PRINT and expr.type != self.builtins.STR:
                expr = self.stringify(expr)
            argvars.push(expr)
        self.code.push(new ir::Instruction(new ir::FunctionCall(func_var, argvars)))

    meth do_block(List[ast::Call] body) -> List[ir::Instruction]:
        # TODO: separate class
        assert(self.code.length() == 0)
        foreach call of body:
            self.do_statement(call)
        return self.code

    meth do_funcdef(ast::FuncDef funcdef) -> ir::FuncDef:
        assert(funcdef.args.length() == 0)
        let functype = new ir::FunctionType(new List[ir::ObjectType]())
        assert(funcdef.name == "main")
        let func_var = new ir::ThisFileVariable(funcdef.name, functype)
        let body = self.do_block(funcdef.body)
        return new ir::FuncDef(func_var, new List[ir::LocalVariable](), body)

export func convert_program(ir::Builtins builtins, List[ast::FuncDef] program) -> List[ir::FuncDef]:
    let result = new List[ir::FuncDef]()
    foreach funcdef of program:
        result.push(new Converter(builtins, new List[ir::Instruction](), 0).do_funcdef(funcdef))
    return result
