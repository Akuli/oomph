import "ast.oomph" as ast
import "ir.oomph" as ir

class Converter(ir::Builtins builtins, List[ir::Instruction] code, int varname_counter):
    meth find_function(Str name) -> ir::BuiltinVariable:
        foreach var of self.builtins.get_variables():
            if var.name == name:
                return var
        assert(false)  # TODO: error

    meth create_var(ir::ObjectType type) -> ir::LocalVariable:
        self.varname_counter = self.varname_counter + 1
        return new ir::LocalVariable(type, self.varname_counter)

    meth do_expression(ast::Expression expr) -> ir::LocalVariable:
        switch expr:
            case ast::BinaryOperator bin_op:
                let lhs_var = self.do_expression(bin_op.lhs)
                let rhs_var = self.do_expression(bin_op.rhs)
                assert(lhs_var.type == self.builtins.INT)
                assert(rhs_var.type == self.builtins.INT)

                if bin_op.op == "+":
                    let function = self.builtins.int_add
                elif bin_op.op == "*":
                    function = self.builtins.int_mul
                else:
                    print("bad bin op: {bin_op}")
                    assert(false)

                let result_var = self.create_var(self.builtins.INT)
                self.code.push(new ir::Instruction(new ir::FunctionCall(function, [lhs_var, rhs_var], new optional[ir::LocalVariable](result_var))))
                return result_var
            case ast::Call call:
                print("call {call}")
                assert(false)  # TODO
            case ast::GetVar getvar:
                print("getvar {getvar}")
                assert(false)  # TODO
            case ast::FloatConstant floatconst:
                let var = self.create_var(self.builtins.FLOAT)
                self.code.push(new ir::Instruction(new ir::FloatConstant(floatconst.value, var)))
            case ast::IntConstant intconst:
                var = self.create_var(self.builtins.INT)
                self.code.push(new ir::Instruction(new ir::IntConstant(intconst.value, var)))
            case ast::StringConstant strconst:
                var = self.create_var(self.builtins.STR)
                self.code.push(new ir::Instruction(new ir::StringConstant(strconst.value, var)))

        return var

    meth stringify(ir::LocalVariable var) -> ir::LocalVariable:
        let result = self.create_var(self.builtins.STR)
        self.code.push(new ir::Instruction(new ir::MethodCall(var, "to_string", new List[ir::LocalVariable](), new optional[ir::LocalVariable](result))))
        return result

    meth do_statement(ast::Call call):
        switch call.function:
            # Currently, functions must be variables
            case ast::GetVar getvar:
                let func_var = self.find_function(getvar.varname)
            case *:
                assert(false)  # TODO: error

        let argvars = new List[ir::LocalVariable]()
        foreach arg of call.args:
            let expr = self.do_expression(arg)
            if func_var == self.builtins.PRINT and expr.type != self.builtins.STR:
                expr = self.stringify(expr)
            argvars.push(expr)
        self.code.push(new ir::Instruction(new ir::FunctionCall(func_var, argvars, null[ir::LocalVariable])))

    meth do_block(List[ast::Call] body) -> List[ir::Instruction]:
        # TODO: separate class
        assert(self.code.length() == 0)
        foreach call of body:
            self.do_statement(call)
        return self.code

    meth do_funcdef(ast::FuncDef funcdef) -> ir::FuncDef:
        assert(funcdef.args.length() == 0)
        let functype = new ir::FunctionType(new List[ir::ObjectType]())
        assert(funcdef.name == "main")
        let func_var = new ir::ThisFileVariable(funcdef.name, functype)
        let body = self.do_block(funcdef.body)
        return new ir::FuncDef(func_var, new List[ir::LocalVariable](), body)

export func convert_program(ir::Builtins builtins, List[ast::FuncDef] program) -> List[ir::FuncDef]:
    let result = new List[ir::FuncDef]()
    foreach funcdef of program:
        result.push(new Converter(builtins, new List[ir::Instruction](), 0).do_funcdef(funcdef))
    return result
