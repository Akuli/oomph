import "<stdlib>/io.oomph" as io

class ShitEntry(Str key, Str value)
class ShitMapping(List[ShitEntry] entries):
    meth set(Str key, Str value):
        foreach entry of self.entries:
            if entry.key == key:
                entry.value = value
                return
        self.entries.push(new ShitEntry(key, value))

    meth get(Str key) -> Str | null:
        foreach entry of self.entries:
            if entry.key == key:
                return entry.value
        return null

    meth delete(Str key) -> Bool:
        foreach entry of self.entries:
            if entry.key == key:
                self.entries.delete_only(entry)
                return true
        return false

    meth keys() -> List[Str]:
        return [foreach entry of self.entries: entry.key]

    meth length() -> Int:
        return self.entries.length()


func hash(Str key) -> Int:
    return key.length()  # lol
class Entry(Str key, Str value, Int hash)
class Mapping(List[Entry | null] entries):
    meth set(Str key, Str value):
        let h = hash(key)
        let i = h mod self.entries.length()
        while self.entries.get(i) != null:
            let entry = self.entries.get(i) as not null
            if entry.hash == h and entry.key == key:
                entry.value = value
                return
            # Jump over this entry
            i = i+1 mod self.entries.length()   # TODO: improve
        self.entries.set(i, new Entry(key, value, h))

    meth get(Str key) -> Str | null:
        let h = hash(key)
        for let i = h mod self.entries.length(); self.entries.get(i) != null; i = i+1:
            let entry = self.entries.get(i) as not null
            if entry.hash == h and entry.key == key:
                return entry.value
        return null

    meth delete(Str key) -> Bool:
        let n = self.entries.length()
        let i = hash(key) mod n
        while true:
            if self.entries.get(i) == null:
                return false
            if (self.entries.get(i) as not null).key == key:
                break
            i = i+1 mod n

        self.entries.set(i, null)

        # Delete and .set() everything that might rely on jumping over the item at i
        for let k = i+1 mod n; self.entries.get(k) != null; k = k+1 mod n:
            let entry = self.entries.set(k, null) as not null
            self.set(entry.key, entry.value)
        return true

    meth keys() -> List[Str]:
        let result = []
        foreach entry of self.entries:
            if entry != null:
                result.push((entry as not null).key)
        return result

    meth length() -> Int:
        let result = 0
        foreach entry of self.entries:
            if entry != null:
                result = result + 1
        return result


func pow(Int a, Int b) -> Int:
    assert(b >= 0)
    let result = 1
    for let i = 0; i < b; i = i+1:
        result = result * a
    return result


class PRNG(Int state, List[Str] strings):
    meth get_number(Int range_end) -> Int:
        # from linux rand(3) man page
        # sticking to mod 32 because oomph doesn't have unsigneds
        let new_state = self.state*1103515245 + 12345
        assert(new_state >= 0)
        self.state = new_state mod pow(2, 32)
        return self.state mod range_end

    meth get_string() -> Str:
        return self.strings.get(self.get_number(self.strings.length()))


func ensure_lists_contain_same_items(List[Str] a, List[Str] b):
    b = b.reversed().reversed()  # make copy, lol
    foreach item of a:
        b.delete_first(item)
    assert(b == [])

func get_strings() -> List[Str]:
    let result = []
    foreach word of io::read_file("self_hosted/ast2ir.oomph").replace("\n", " ").split(" "):
        if word != "":
            result.push(word)
    return result


export func main():
    let prng = new PRNG(1234, get_strings())
    let n = 8  # number of buckets

    let n = 3000
    let mapping1 = new Mapping([for let i = 0; i < n; i = i+1: null as Entry | null])
    let mapping2 = new ShitMapping([])

    for let i = 0; i < n; i = i+1:
        let operation = prng.get_number(3)

        if operation == 0:
            # Set
            let key = prng.get_string()
            let value = prng.get_string()
            mapping1.set(key, value)
            mapping2.set(key, value)
        elif operation == 1:
            # Get
            let key = prng.get_string()
            assert(mapping1.get(key) == mapping2.get(key))
        elif operation == 2:
            # Delete
            let key = prng.get_string()
            assert(mapping1.delete(key) == mapping2.delete(key))

        assert(mapping1.length() == mapping2.length())
        ensure_lists_contain_same_items(mapping1.keys(), mapping2.keys())

    print("ok")
