import "ast.oomph" as ast
import "ir.oomph" as ir
import "location.oomph" as location
typedef Location = location::Location

# TODO: tuples
class LoopLabels(ir::GotoLabel continue_label, ir::GotoLabel break_label)
class AutoTypePair(ir::AutoType first, ir::AutoType second)
class TypePair(ir::Type first, ir::Type second)


# TODO: shouldn't be needed
func is_autotype(ir::Type type) -> Bool:
    switch type:
        case ir::AutoType autotype:
            return true
        case *:
            return false

# TODO: get rid of this?
func find_variable(
    Mapping[Str, ir::Variable] variables,
    Str name,
    Location | null location,  # if user can make variable not found, then must be non-null
) -> ir::Variable:
    if not variables.has_key(name):
        (location as not null).error("variable not found: {name}")
    return variables.get(name)


# Returns the same result every time, regardless of order of input list
func pick_one_autotype(List[ir::AutoType] autotypes) -> ir::AutoType:
    # TODO: would be so nice to write 'return autotypes.min(.id)
    let result = autotypes.first()
    foreach autotype of autotypes:
        if autotype.id < result.id:
            result = autotype
    return result


func get_type_members(ir::Type type) -> List[ir::Type]:
    switch type:
        case ir::UnionType union:
            return union.type_members
        # FIXME: somehow this gets called with auto types
#        case ir::AutoType _:
#            assert(false)
        case *:
            return [type]


class FunctionOrMethodConverter(
    ir::Builtins builtins,
    FileConverter file_converter,
    Mapping[Str, ir::Variable] variables,
    ir::Type | null returntype,
    List[LoopLabels] loop_stack,
    List[ir::Instruction] code,
    List[List[ir::Instruction]] code_stack,
    Mapping[ir::AutoType, ir::Type] resolved_autotypes,
    List[AutoTypePair] matching_autotypes,
    Int autotype_counter,
    Int goto_label_counter,
    Int local_var_counter,
):
    meth create_var(ir::Type type, Location location) -> ir::LocalVariable:
        self.local_var_counter = self.local_var_counter + 1
        let result = new ir::LocalVariable(type, self.local_var_counter, location)

        # Newly created variables must be decreffed, in case we are in a loop.
        # Also, after decreffing, make sure that another iteration of loop
        # won't decref the same variable again.
        self.code.push(new ir::DecRef(result))
        self.code.push(new ir::UnSet(result))
        return result

    meth get_var(Str name, Location | null location) -> ir::Variable:
        return find_variable(self.variables, name, location)

    meth get_matching_autotype_list(ir::AutoType autotype) -> List[ir::AutoType]:
        # TODO: transitivity? if (A,B) and (B,C) in matching_autotypes then A --> [A,B,C]
        let matches = [autotype]
        foreach pair of self.matching_autotypes:
            if pair.first == autotype and pair.second not in matches:
                matches.push(pair.second)
            if pair.second == autotype and pair.first not in matches:
                matches.push(pair.first)
        return matches

    meth resolve_autotype(ir::AutoType autotype, ir::Type actual):
        assert(not is_autotype(actual))
        if self.resolved_autotypes.has_key(autotype):
            assert(self.resolved_autotypes.get(autotype) == actual)  # TODO: error
        else:
            foreach matching of self.get_matching_autotype_list(autotype):
                self.resolved_autotypes.set(matching, actual)

    meth substitute_autotypes(ir::Type type, Bool must_succeed) -> ir::Type:
        if is_autotype(type):
            if self.resolved_autotypes.has_key(type as ir::AutoType):
                return self.resolved_autotypes.get(type as ir::AutoType)
            assert(not must_succeed)
            return pick_one_autotype(self.get_matching_autotype_list(type as ir::AutoType))

        let source = ir::get_generic_source(type)
        if source == null:
            return type

        # TODO: provide location here?
        return self.builtins.generic2type((source as not null).generik, [
            foreach arg of (source as not null).args:
                self.substitute_autotypes(arg, must_succeed)
        ], null)

    meth create_autotype() -> ir::AutoType:
        self.autotype_counter = self.autotype_counter + 1
        return new ir::AutoType(self.autotype_counter)

    meth create_goto_label() -> ir::GotoLabel:
        self.goto_label_counter = self.goto_label_counter + 1
        return new ir::GotoLabel(self.goto_label_counter)

    meth get_type(ast::Type raw_type) -> ir::Type:
        switch raw_type:
            case ast::AutoType autotype:
                return self.create_autotype()
            case *:
                return self.file_converter.get_type(raw_type, self)

    # TODO: something like @contextlib.contextmanager in python?
    meth push_code():
        self.code_stack.push(self.code)
        self.code = new List[ir::Instruction]()  # FIXME: auto types not work

    meth pop_code() -> List[ir::Instruction]:
        let result = self.code
        self.code = self.code_stack.pop()
        return result

    meth stringify(ir::LocalVariable var) -> ir::LocalVariable:
        if var.type == self.builtins.STR:
            return var

        let result_var = self.create_var(self.builtins.STR, var.location)
        let to_string_call = new ir::MethodCall(
            var, "to_string", [], result_var, var.location
        ) as ir::Instruction

        switch var.type:
            case ir::UnionType union:
                if self.builtins.STR in union.type_members:
                    # For unions containing string, output the string without quotes
                    let its_a_string = self.create_var(self.builtins.BOOL, var.location)
                    self.code.push(new ir::UnionMemberCheck(its_a_string, var, self.builtins.STR))
                    self.do_if(its_a_string, [
                        new ir::GetFromUnion(result_var, var) as ir::Instruction,
                        new ir::IncRef(result_var) as ir::Instruction,
                    ], [to_string_call])
                    return result_var
            case *:
                pass

        self.code.push(to_string_call)
        return result_var

    meth create_special_call(Str name, List[ir::LocalVariable] args) -> ir::LocalVariable:
        # Not perfect, but doesn't matter much
        let location = args.first().location
        foreach arg of args.slice(1, args.length()):
            location = location.combine(arg.location)

        let function = self.builtins.get_hidden_var(name)
        let result_var = self.create_var(
            (function.type as ir::FunctionType).returntype as ir::Type,
            location
        )
        self.code.push(new ir::FunctionCall(function, args, result_var))
        return result_var

    # TODO: get rid of this
    meth lookup_autotype(ir::AutoType autotype) -> ir::Type | null:
        if self.resolved_autotypes.has_key(autotype):
            return self.resolved_autotypes.get(autotype)
        return null

    meth do_the_autotype_thing(ir::Type type1, ir::Type type2, Location location) -> TypePair:
        if is_autotype(type1) and is_autotype(type2):
            if type1 != type2:
                let actual_type1 = self.lookup_autotype(type1 as ir::AutoType)
                let actual_type2 = self.lookup_autotype(type2 as ir::AutoType)
                if actual_type1 != null and actual_type2 != null:
                    return new TypePair(actual_type1 as not null, actual_type2 as not null)
                if actual_type1 != null:
                    return new TypePair(actual_type1 as not null, type2)
                if actual_type2 != null:
                    return new TypePair(type1, actual_type2 as not null)

                self.matching_autotypes.push(new AutoTypePair(type1 as ir::AutoType, type2 as ir::AutoType))
                # TODO: should be consistent with substitute_autotypes?
                return new TypePair(type1, type1)

        elif is_autotype(type1):
            let resolved = self.lookup_autotype(type1 as ir::AutoType)
            if resolved != null:
                return new TypePair(resolved as not null, type2)
            self.resolve_autotype(type1 as ir::AutoType, type2)
            return new TypePair(type2, type2)

        elif is_autotype(type2):
            let resolved = self.lookup_autotype(type2 as ir::AutoType)
            if resolved != null:
                return new TypePair(type1, resolved as not null)
            self.resolve_autotype(type2 as ir::AutoType, type1)
            return new TypePair(type1, type1)

        else:
            # TODO: this nestedness sucks
            let type1_source = ir::get_generic_source(type1)
            let type2_source = ir::get_generic_source(type2)
            if type1_source != null and type2_source != null:
                let source1 = type1_source as not null
                let source2 = type2_source as not null
                if source1.generik == source2.generik:
                    # Handle List[Str] matching List[auto]
                    # TODO: error
                    assert(source1.args.length() == source2.args.length())
                    let pairs = [
                        # TODO: zip
                        for let i = 0; i < source1.args.length(); i = i+1:
                            self.do_the_autotype_thing(source1.args.get(i), source2.args.get(i), location)
                    ]
                    return new TypePair(
                        self.builtins.generic2type(source1.generik, [foreach p of pairs: p.first], location),
                        self.builtins.generic2type(source2.generik, [foreach p of pairs: p.second], location),
                    )

        return new TypePair(type1, type2)

    meth union_conversion(ir::LocalVariable var, ir::Type target_type) -> ir::LocalVariable:
        let conversion_result = self.create_var(target_type, var.location)

        switch var.type:
            case ir::UnionType union_vartype:
                let bool_var = self.create_var(self.builtins.BOOL, var.location)
                let end_code = new List[ir::Instruction]()
                let done_label = self.create_goto_label()

                foreach member of union_vartype.type_members:
                    if member in get_type_members(target_type):
                        let label = self.create_goto_label()
                        self.code.push(new ir::UnionMemberCheck(bool_var, var, member))
                        self.code.push(new ir::GotoIf(label, bool_var))

                        self.push_code()
                        self.code.push(label)  # must be before create_var
                        let get_result = self.create_var(member, var.location)
                        self.code.push(new ir::GetFromUnion(get_result, var))
                        self.code.push(new ir::IncRef(get_result))
                        switch target_type:
                            case ir::UnionType u:
                                self.code.push(new ir::InstantiateUnion(conversion_result, get_result))
                            case *:
                                self.code.push(new ir::VarCpy(conversion_result, get_result))
                        self.code.push(new ir::IncRef(conversion_result))
                        self.code.push(new ir::GotoIf(done_label, self.bool_constant("true", var.location)))
                        end_code.push_all(self.pop_code())

                self.code.push(new ir::Panic("'as' failed", var.location))   # TODO: better error message?
                self.code.push_all(end_code)
                self.code.push(done_label)
                return conversion_result

            case *:
                switch target_type:
                    case ir::UnionType target_union:
                        assert(var.type in target_union.type_members)  # TODO: error
                        self.code.push(new ir::InstantiateUnion(conversion_result, var))
                        self.code.push(new ir::IncRef(conversion_result))
                        return conversion_result
                    case *:
                        # TODO: uncommenting this causes funny autotype corner case and test fail
                        #assert(var.type == target_type)
                        return var

    meth implicit_conversion_if_possible(
        ir::LocalVariable var,
        ir::Type target_type,
    ) -> ir::LocalVariable | null:
        let pair = self.do_the_autotype_thing(var.type, target_type, var.location)
        var.type = pair.first
        target_type = pair.second

        if var.type == self.builtins.INT and target_type == self.builtins.FLOAT:
            return self.create_special_call("int2float", [var])

        foreach member of get_type_members(var.type):
            if member not in get_type_members(target_type):
                return null
        return self.union_conversion(var, target_type)

    meth implicit_conversion(ir::LocalVariable var, ir::Type type) -> ir::LocalVariable:
        let result = self.implicit_conversion_if_possible(var, type)
        if result == null:
            var.location.error(
                "wrong type: should be {ir::type_name(type)}, but it's {ir::type_name(var.type)}"
            )
        return result as not null

    # Can be called multiple times, that doesn't matter
    meth do_args(
        List[ir::LocalVariable] args,
        List[ir::Type] target_types,
        Location func_location,
    ) -> List[ir::LocalVariable]:
        if args.length() != target_types.length():
            if target_types.length() == 1:
                let s = ""
            else:
                s = "s"
            func_location.error("expected {target_types.length()} argument{s}, got {args.length()}")

        # TODO: zip
        return [
            for let i = 0; i < args.length(); i = i+1:
            self.implicit_conversion(args.get(i), target_types.get(i))
        ]

    # TODO: get rid of this
    meth get_method_functype(ir::Type type, Str name) -> ir::FunctionType:
        return ir::get_method(type, name, self.builtins)

    # TODO: get rid of this
    meth get_attribute_type(ir::Type type, Str attribute) -> ir::Type:
        return ir::get_member(type, attribute)

    meth do_call(ast::Call call, Bool must_return_value) -> ir::LocalVariable | null:
        let args = [foreach arg of call.args: self.do_expression(arg)]
        let result_var = null as ir::LocalVariable | null

        switch call.function:
            case ast::GetAttribute method:
                let self_var = self.do_expression(method.obj)

                self_var.type = self.substitute_autotypes(self_var.type, false)
                switch self_var.type:
                    case ir::AutoType self_autotype:
                        # Less type information available, do_args will be called later
                        if must_return_value:
                            result_var = self.create_var(self.create_autotype(), call.location)
                    case *:
                        let functype = self.get_method_functype(self_var.type, method.attribute)
                        assert(self_var.type == functype.argtypes.first())

                        switch functype.returntype:
                            case ir::Type typ:
                                result_var = self.create_var(typ, call.location)
                            case *:
                                pass

                        args = self.do_args(
                            args,
                            functype.argtypes.slice(1, functype.argtypes.length()),
                            call.location
                        )
                self.code.push(new ir::MethodCall(
                    self_var, method.attribute, args, result_var, call.location
                ))

            case ast::GetVar ast_function:
                let function = self.get_var(ast_function.varname, ast_function.location)
                let functype = ir::var_type(function) as ir::FunctionType

                switch functype.returntype:
                    case ir::Type typ:
                        result_var = self.create_var(typ, call.location)
                    case *:
                        pass

                if function == self.builtins.get_visible_var("print"):
                    if args.length() != 1:
                        ast_function.location.error("print must be called with 1 argument")
                    args = [foreach arg of args: self.stringify(arg)]
                else:
                    if function == self.builtins.get_visible_var("assert"):
                        if args.length() != 1:
                            ast_function.location.error("assert must be called with 1 argument")
                        # Add path and line number args
                        let loc = ast_function.location
                        args.push(self.do_expression(new ast::StringConstant(loc, loc.path)))
                        args.push(self.do_expression(new ast::IntConstant(loc, loc.lineno)))
                    args = self.do_args(
                        args,
                        functype.argtypes,
                        ast_function.location,
                    )
                self.code.push(new ir::FunctionCall(function, args, result_var))

            case ast::Constructor constructor:
                let type = self.get_type(constructor.type)
                let argtypes = ir::get_constructor_argtypes(type)
                if argtypes == null:
                    constructor.location.error("type '{ir::type_name(type)}' has no constructor")

                args = self.do_args(args, argtypes as not null, constructor.location)
                result_var = self.create_var(type, call.location)
                self.code.push(new ir::ConstructorCall(result_var as not null, args))

            case *:
                assert(false)

        return result_var


    meth not_(ir::LocalVariable obj) -> ir::LocalVariable:
        return self.create_special_call("bool_not", [obj])

    meth bool_constant(Str which, Location location) -> ir::LocalVariable:
        let result = self.create_var(self.builtins.BOOL, location)
        self.code.push(new ir::VarCpy(result, self.builtins.get_visible_var("true")))
        return result

    meth do_binary_op_typed(ir::LocalVariable lhs, Str op, Location op_location, ir::LocalVariable rhs) -> ir::LocalVariable:
        if op in ["in", "not in"]:
            let result_var = self.create_var(self.builtins.BOOL, op_location)
            self.code.push(new ir::MethodCall(
                rhs, "__contains", [lhs], result_var, op_location
            ))
            if op == "not in":
                return self.not_(result_var)
            return result_var

        # See docs/implicit-conversions.md
        if lhs.type != rhs.type:
            let new_lhs = self.implicit_conversion_if_possible(lhs, rhs.type)
            let new_rhs = self.implicit_conversion_if_possible(rhs, lhs.type)
            if new_lhs == null and new_rhs != null:
                rhs = new_rhs as not null
            elif new_lhs != null and new_rhs == null:
                lhs = new_lhs as not null

        assert(self.substitute_autotypes(lhs.type, false) == self.substitute_autotypes(rhs.type, false))
        let type = self.substitute_autotypes(lhs.type, false)

        if op == "!=":
            return self.not_(self.do_binary_op_typed(lhs, "==", op_location, rhs))

        # Reduce >=, <=, and < to use >
        if op == "<":
            return self.do_binary_op_typed(rhs, ">", op_location, lhs)
        if op == "<=":
            return self.not_(self.do_binary_op_typed(lhs, ">", op_location, rhs))
        if op == ">=":
            return self.not_(self.do_binary_op_typed(lhs, "<", op_location, rhs))

        if type == self.builtins.STR and op == "+":
            # TODO: add something to make a+b+c more efficient than (a+b)+c
            return self.create_special_call("string_concat", [lhs, rhs])

        if type == self.builtins.INT and op == "+":
            return self.create_special_call("int_add", [lhs, rhs])
        if type == self.builtins.INT and op == "-":
            return self.create_special_call("int_sub", [lhs, rhs])
        if type == self.builtins.INT and op == "*":
            return self.create_special_call("int_mul", [lhs, rhs])
        if type == self.builtins.INT and op == "mod":
            return self.create_special_call("int_mod", [lhs, rhs])
        if type == self.builtins.INT and op == ">":
            return self.create_special_call("int_gt", [lhs, rhs])

        if type == self.builtins.INT and op == "/":
            lhs = self.create_special_call("int2float", [lhs])
            rhs = self.create_special_call("int2float", [rhs])
            type = self.builtins.FLOAT

        if type == self.builtins.FLOAT and op == "+":
            return self.create_special_call("float_add", [lhs, rhs])
        if type == self.builtins.FLOAT and op == "-":
            return self.create_special_call("float_sub", [lhs, rhs])
        if type == self.builtins.FLOAT and op == "*":
            return self.create_special_call("float_mul", [lhs, rhs])
        if type == self.builtins.FLOAT and op == "/":
            return self.create_special_call("float_div", [lhs, rhs])
        if type == self.builtins.FLOAT and op == "mod":
            return self.create_special_call("float_mod", [lhs, rhs])
        if type == self.builtins.FLOAT and op == ">":
            return self.create_special_call("float_gt", [lhs, rhs])

        if op == "==":
            result_var = self.create_var(self.builtins.BOOL, op_location)
            self.code.push(new ir::MethodCall(lhs, "equals", [rhs], result_var, op_location))
            return result_var

        print("wrong types: {ir::type_name(type)} {op} {ir::type_name(type)}")
        assert(false)  # TODO: error

    meth do_if(ir::LocalVariable cond, List[ir::Instruction] then, List[ir::Instruction] otherwise):
        let then_label = self.create_goto_label()
        let done_label = self.create_goto_label()
        self.code.push(new ir::GotoIf(then_label, cond))
        self.code.push_all(otherwise)
        self.code.push(new ir::GotoIf(done_label, self.bool_constant("true", cond.location)))
        self.code.push(then_label)
        self.code.push_all(then)
        self.code.push(done_label)

    meth do_binary_op(ast::BinaryOperator op_ast) -> ir::LocalVariable:
        # Avoid evaluating right side when not needed
        # TODO: mention this in docs
        if op_ast.op in ["and", "or"]:
            let lhs_var = self.do_expression_and_convert(op_ast.lhs, self.builtins.BOOL)
            let result_var = self.create_var(self.builtins.BOOL, op_ast.location)

            self.push_code()
            let rhs_var = self.do_expression_and_convert(op_ast.rhs, self.builtins.BOOL)
            let rhs_evaluation = self.pop_code()
            rhs_evaluation.push(new ir::VarCpy(result_var, rhs_var))

            if op_ast.op == "and":
                self.do_if(
                    lhs_var,
                    rhs_evaluation,
                    [
                        new ir::VarCpy(
                            result_var, self.builtins.get_visible_var("false")
                        ) as ir::Instruction
                    ],
                )
            else:
                self.do_if(
                    lhs_var,
                    [
                        new ir::VarCpy(
                            result_var, self.builtins.get_visible_var("true")
                        ) as ir::Instruction
                    ],
                    rhs_evaluation,
                )
            return result_var

        let lhs = self.do_expression(op_ast.lhs)
        let rhs = self.do_expression(op_ast.rhs)
        return self.do_binary_op_typed(lhs, op_ast.op, op_ast.location, rhs)

    # Always returns new variable
    meth do_expression(ast::Expression expr) -> ir::LocalVariable:
        let location = ast::locate_expression(expr)

        switch expr:
            case ast::IntConstant int:
                # This accepts int64_t values only, because the value has already been converted to int
                let var = self.create_var(self.builtins.INT, location)
                self.code.push(new ir::IntConstant(int.value, var))
                return var

            case ast::FloatConstant float:
                let var = self.create_var(self.builtins.FLOAT, location)
                self.code.push(new ir::FloatConstant(float.value, var))
                return var

            case ast::StringConstant string:
                let var = self.create_var(self.builtins.STR, location)
                self.code.push(new ir::StringConstant(string.value, var))
                return var

            case ast::ListLiteral list:
                let content = [foreach expr of list.content: self.do_expression(expr)]
                if content == []:
                    let content_type = self.create_autotype() as ir::Type
                else:
                    content_type = content.first().type
                    foreach member of content:
                        assert(member.type == content_type)  # TODO: error

                let list_var = self.create_var(
                    self.builtins.generic2type(self.builtins.LIST, [content_type], location), location
                )
                self.code.push(new ir::ConstructorCall(list_var, []))
                foreach item_var of content:
                    self.code.push(new ir::MethodCall(
                        list_var, "push", [item_var], null, location
                    ))
                return list_var

            case ast::StringFormatJoin join:
                assert(join.parts.length() >= 2)
                let result = self.stringify(self.do_expression(join.parts.first()))
                foreach part of join.parts.slice(1, join.parts.length()):
                    # TODO: this results in slow nested code
                    result = self.create_special_call(
                        "string_concat", [result, self.stringify(self.do_expression(part))]
                    )
                return result

            case ast::Call call:
                # TODO: error?
                return self.do_call(call, true) as not null

            case ast::GetVar getvar:
                # Don't return the same variable, otherwise 'a = a' decrefs too much
                # Also ensure we always return LocalVariable
                let old_var = self.get_var(getvar.varname, location)
                let new_var = self.create_var(ir::var_type(old_var), location)
                self.code.push(new ir::VarCpy(new_var, old_var))
                self.code.push(new ir::IncRef(new_var))
                return new_var

            case ast::UnaryOperator unary:
                let obj = self.do_expression(unary.obj)
                if unary.op == "not":
                    return self.create_special_call("bool_not", [
                        self.implicit_conversion(obj, self.builtins.BOOL)
                    ])
                # TODO: auto type support (remember docs)
                if obj.type == self.builtins.INT and unary.op == "-":
                    return self.create_special_call("int_neg", [obj])
                if obj.type == self.builtins.FLOAT and unary.op == "-":
                    return self.create_special_call("float_neg", [obj])
                # TODO: error
                print("wrong types: {unary.op}{ir::type_name(obj.type)}")
                assert(false)

            case ast::BinaryOperator binary:
                return self.do_binary_op(binary)

            case ast::GetAttribute getattr:
                let obj = self.do_expression(getattr.obj)
                obj.type = self.substitute_autotypes(obj.type, false)
                switch obj.type:
                    case ir::AutoType autotype:
                        let result = self.create_var(
                            self.create_autotype(), location
                        )
                    case *:
                        result = self.create_var(
                            self.get_attribute_type(obj.type, getattr.attribute),
                            location
                        )
                self.code.push(new ir::GetAttribute(obj, result, getattr.attribute))
                self.code.push(new ir::IncRef(result))
                return result

            case ast::StatementsAndExpression sae:
                foreach s of sae.statements:
                    self.do_statement(s)
                return self.do_expression(sae.expression)

            case ast::As ass:
                let value = self.do_expression(ass.expr)
                let target_type = self.get_type(ass.type)

                if ass.as_not:
                    switch value.type:
                        case ir::UnionType u:
                            if target_type not in u.type_members:
                                value.location.error(
                                    "left side of 'as not' has union type '{ir::type_name(u)}', "
                                    + "which doesn't have member '{ir::type_name(target_type)}'"
                                )

                            let new_members = u.type_members.copy()
                            new_members.delete_only(target_type)

                            if new_members.length() >= 2:
                                target_type = ir::make_union(self.builtins, new_members, null)
                            else:
                                target_type = new_members.first()

                        case *:
                            value.location.error(
                                "left side of 'as not' must have union type, not {ir::type_name(value.type)}"
                            )

                elif value.type == target_type:
                    ass.location.error(
                        "unnecessary 'as' conversion from {ir::type_name(value.type)} to {ir::type_name(target_type)}"
                    )

                return self.union_conversion(value, target_type)

            case ast::Constructor _:
                # TODO: constructor functions as first-class objects
                assert(false)

            case ast::Parenthesized | ast::ListComprehension _:
                # ast_transformer hasn't done its job
                assert(false)

    meth do_expression_and_convert(ast::Expression expr, ir::Type type) -> ir::LocalVariable:
        return self.implicit_conversion(self.do_expression(expr), type)

    meth do_statement(ast::Statement stmt):
        switch stmt:
            case ast::Call call:
                self.do_call(call, false)

            case ast::Let leet:
                # TODO: document the shadowing/replacing behaviour
                self.variables.set(leet.varname, self.do_expression(leet.value))

            case ast::SetVar setvar:
                let var = self.get_var(setvar.varname, setvar.location) as ir::LocalVariable  # TODO: error
                let new_value_var = self.do_expression(setvar.value)
                self.code.push(new ir::DecRef(var))
                self.code.push(
                    new ir::VarCpy(var, self.implicit_conversion(new_value_var, var.type))
                )
                self.code.push(new ir::IncRef(var))

            case ast::SetAttribute setattr:
                let obj = self.do_expression(setattr.obj)
                let new_value_var = self.do_expression(setattr.value)

                if ir::get_member(obj.type, setattr.attribute) != new_value_var.type:
                    # TODO: error
                    print("wrong type for attribute {setattr.attribute} of type {ir::type_name(obj.type)}")
                    assert(false)

                # Copy old value into local var, so that it will be decreffed
                let old_value_var = self.create_var(new_value_var.type, setattr.attribute_location)
                self.code.push(new ir::GetAttribute(obj, old_value_var, setattr.attribute))
                self.code.push(new ir::SetAttribute(obj, setattr.attribute, new_value_var))
                self.code.push(new ir::IncRef(new_value_var))

            case ast::Pass p:
                pass

            case ast::Continue cont:
                let label = self.loop_stack.last().continue_label
                self.code.push(new ir::GotoIf(label, self.bool_constant("true", cont.location)))

            case ast::Break bread:
                let label = self.loop_stack.last().break_label
                self.code.push(new ir::GotoIf(label, self.bool_constant("true", bread.location)))

            case ast::Return ret:
                if self.returntype == null:
                    assert(ret.value == null)  # TODO: error
                    self.code.push(new ir::Return(null))
                else:
                    # TODO: improve error for missing return value
                    # TODO: error for missing return statement
                    self.code.push(new ir::Return(self.do_expression_and_convert(
                        ret.value as not null, self.returntype as not null,
                    )))

            case ast::If if_statement:
                let untyped_condition = if_statement.ifs_and_elifs.first().cond
                let untyped_body = if_statement.ifs_and_elifs.first().body
                let condition = self.do_expression_and_convert(untyped_condition, self.builtins.BOOL)
                let body = self.do_block(untyped_body)

                if if_statement.ifs_and_elifs.length() >= 2:
                    let otherwise = self.do_block([
                        new ast::If(
                            if_statement.ifs_and_elifs.slice(1, if_statement.ifs_and_elifs.length()),
                            if_statement.else_block,
                        ) as ast::Statement
                    ])
                else:
                    otherwise = self.do_block(if_statement.else_block)
                self.do_if(condition, body, otherwise)

            case ast::Loop loop:
                let cond_label = self.create_goto_label()
                let continue_label = self.create_goto_label()
                let break_label = self.create_goto_label()

                let header = loop.loop_header as ast::ForLoopHeader

                foreach init of header.init:
                    self.do_statement(init)

                self.code.push(cond_label)
                if header.cond == null:
                    let cond_var = self.create_var(
                        self.builtins.BOOL, header.keyword_location
                    )
                    self.code.push(new ir::VarCpy(
                        cond_var, self.builtins.get_visible_var("true")
                    ))
                else:
                    cond_var = self.do_expression_and_convert(header.cond as not null, self.builtins.BOOL)
                self.code.push(new ir::GotoIf(break_label, self.not_(cond_var)))

                self.loop_stack.push(new LoopLabels(continue_label, break_label))
                self.code.push_all(self.do_block(loop.body))
                let popped = self.loop_stack.pop()
                assert(popped.continue_label == continue_label)
                assert(popped.break_label == break_label)

                self.code.push(continue_label)
                foreach incr of header.incr:
                    self.do_statement(incr)
                self.code.push(new ir::GotoIf(
                    cond_label,
                    self.bool_constant("true", ast::locate_loop_header(loop.loop_header))
                ))
                self.code.push(break_label)

                if header.init.length() == 1:
                    switch header.init.first():
                        case ast::Let leet:
                            if self.variables.has_key(leet.varname):
                                self.variables.delete(leet.varname)
                        case *:
                            pass

            case ast::Switch switchie:
                let union_var = self.do_expression(switchie.union_obj)
                let union_type = union_var.type as ir::UnionType
                let types_to_do = union_type.type_members.copy()

                let done_label = self.create_goto_label()
                let member_check = self.create_var(self.builtins.BOOL, switchie.location)
                let cases = new List[ir::Instruction]()

                foreach chase of switchie.cases:
                    let label = self.create_goto_label()
                    cases.push(label)

                    if chase.type_and_name == null:
                        assert(types_to_do != [])
                        let nice_types = types_to_do
                        types_to_do = []
                    else:
                        let varname = (chase.type_and_name as not null).name
                        let case_type = self.get_type((chase.type_and_name as not null).type)

                        nice_types = get_type_members(case_type)
                        foreach t of nice_types:
                            if t in types_to_do:
                                types_to_do.delete_only(t)
                            else:
                                # TODO: test this
                                # TODO: types_to_do isn't necessarily union_type.type_members
                                let message = "{ir::type_name(union_type)} does not include {ir::type_name(t)}"
                                switch case_type:
                                    case ir::UnionType _:
                                        message = message + ", which is a member of {ir::type_name(case_type)}"
                                    case *:
                                        pass
                                chase.location.error(message)

                        self.push_code()
                        let case_var = self.union_conversion(union_var, case_type)
                        let case_code = self.pop_code()

                        cases.push_all(case_code)
                        # TODO: error
                        assert(not self.variables.has_key(varname))
                        self.variables.set(varname, case_var)

                    cases.push_all(self.do_block(chase.body))
                    cases.push(new ir::GotoIf(done_label, self.bool_constant("true", chase.location)))

                    if chase.type_and_name != null:
                        assert(self.variables.get(varname) == case_var)
                        self.variables.delete(varname)

                    foreach type of nice_types:
                        self.code.push(new ir::UnionMemberCheck(member_check, union_var, type))
                        self.code.push(new ir::GotoIf(label, member_check))

                if types_to_do != []:
                    switchie.location.error("types not handled in switch: " + [
                        foreach t of types_to_do: ir::type_name(t)
                    ].join(", "))

                # TODO: add panic to self.code to run when no union members matched
                self.code.push_all(cases)
                self.code.push(done_label)

    meth do_block(List[ast::Statement] block) -> List[ir::Instruction]:
        self.push_code()
        foreach stmt of block:
            self.do_statement(stmt)
        return self.pop_code()

    meth get_rid_of_auto_in_var(ir::Variable var):
        switch var:
            case ir::LocalVariable local_var:
                local_var.type = self.substitute_autotypes(local_var.type, true)
            case *:
                pass

    meth get_rid_of_auto_everywhere():
        # Method calls can happen before the type is known. Here we assume that
        # the types got figured out.
        foreach ins of self.code.copy():
            switch ins:
                case ir::MethodCall call:
                    self.get_rid_of_auto_in_var(call.obj)
                    let functype = self.get_method_functype(call.obj.type, call.method_name)

                    self.push_code()
                    call.args = self.do_args(
                        call.args,
                        functype.argtypes.slice(1, functype.argtypes.length()),
                        call.location
                    )
                    let front_code = self.pop_code()

                    let i = self.code.find_only(call)
                    # TODO: insert_sublist method to handle this
                    foreach item of front_code.reversed():
                        self.code.insert(i, item)

                    if functype.returntype == null:
                        # TODO: is this needed? when does it run?
                        assert(call.result == null)
                    elif call.result != null:
                        switch (call.result as not null).type:
                            case ir::AutoType autotype:
                                self.resolve_autotype(autotype, functype.returntype as ir::Type)
                            case *:
                                self.get_rid_of_auto_in_var(call.result as not null)

                    foreach arg of call.args:
                        self.get_rid_of_auto_in_var(arg)

                case ir::GetAttribute getattr:
                    self.get_rid_of_auto_in_var(getattr.obj)
                    switch getattr.attribute_var.type:
                        case ir::AutoType autotype:
                            self.resolve_autotype(
                                autotype,
                                self.get_attribute_type(getattr.obj.type, getattr.attribute))
                        case *:
                            self.get_rid_of_auto_in_var(getattr.attribute_var)

                case *:
                    pass

        foreach ins of self.code:
            switch ins:
                # TODO: union attribs https://github.com/Akuli/oomph/issues/145
                case ir::IncRef ins2:
                    self.get_rid_of_auto_in_var(ins2.var)
                case ir::DecRef ins2:
                    self.get_rid_of_auto_in_var(ins2.var)
                case ir::UnSet ins2:
                    self.get_rid_of_auto_in_var(ins2.var)
                case ir::IntConstant ins2:
                    self.get_rid_of_auto_in_var(ins2.var)
                case ir::FloatConstant ins2:
                    self.get_rid_of_auto_in_var(ins2.var)
                case ir::StringConstant ins2:
                    self.get_rid_of_auto_in_var(ins2.var)

                case ir::MethodCall call:
                    pass  # done separately above

                case ir::ConstructorCall call:
                    self.get_rid_of_auto_in_var(call.result)
                    foreach arg of call.args:
                        self.get_rid_of_auto_in_var(arg)

                case ir::FunctionCall call:
                    if call.result != null:
                        self.get_rid_of_auto_in_var(call.result as not null)
                    self.get_rid_of_auto_in_var(call.function)
                    foreach arg of call.args:
                        self.get_rid_of_auto_in_var(arg)

                case ir::VarCpy varcpy:
                    self.get_rid_of_auto_in_var(varcpy.dest)
                    self.get_rid_of_auto_in_var(varcpy.source)

                case ir::GotoIf goto:
                    self.get_rid_of_auto_in_var(goto.cond)

                case ir::Return ret:
                    if ret.value != null:
                        self.get_rid_of_auto_in_var(ret.value as not null)

                case ir::InstantiateUnion instantiate:
                    self.get_rid_of_auto_in_var(instantiate.result)
                    self.get_rid_of_auto_in_var(instantiate.value)

                # TODO: union attribs https://github.com/Akuli/oomph/issues/145
                case ir::GetAttribute getattr:
                    self.get_rid_of_auto_in_var(getattr.attribute_var)
                    self.get_rid_of_auto_in_var(getattr.obj)
                case ir::SetAttribute setattr:
                    self.get_rid_of_auto_in_var(setattr.attribute_var)
                    self.get_rid_of_auto_in_var(setattr.obj)

                case ir::GetFromUnion get:
                    self.get_rid_of_auto_in_var(get.result)
                    self.get_rid_of_auto_in_var(get.union_var)

                case ir::UnionMemberCheck member_check:
                    self.get_rid_of_auto_in_var(member_check.result)
                    self.get_rid_of_auto_in_var(member_check.union_var)

                case ir::GotoLabel | ir::Panic _:
                    pass


class FileConverter(
    ir::Builtins builtins,
    Str path,
    List[ir::Symbol] symbols,
    Mapping[Str, ir::Type] types,
    Mapping[Str, ir::Generic] generics,
    Mapping[Str, ir::Variable] variables,
    Mapping[Str, ast::Type] typedef_laziness,
):
    # TODO: get rid of this?
    meth add_var(ir::Variable var, Str name):
        assert(not self.variables.has_key(name))
        self.variables.set(name, var)

    meth get_var(Str name, Location | null location) -> ir::Variable:
        return find_variable(self.variables, name, location)

    meth get_named_type(Str name) -> ir::Type:
        if self.typedef_laziness.has_key(name):
            # step 2 stuff
            # TODO: mapping.delete() should return the value
            let ast_type = self.typedef_laziness.get(name)
            self.typedef_laziness.delete(name)
            assert(not self.types.has_key(name))
            self.types.set(name, self.get_type(ast_type, null))

        if self.types.has_key(name):
            return self.types.get(name)
        print("no type named '{name}'")
        assert(false)   # TODO: error

    # TODO: simplify how2recurse stuff
    meth get_type(ast::Type raw_type, FunctionOrMethodConverter | null how2recurse) -> ir::Type:
        switch raw_type:
            case ast::AutoType autotype:
                # TODO: test this
                autotype.location.error("can't use auto type here")

            case ast::NamedType named_type:
                return self.get_named_type(named_type.name)

            case ast::UnionType union_type:
                if how2recurse == null:
                    let types = [foreach t of union_type.unioned: self.get_type(t, null)]
                else:
                    types = [foreach t of union_type.unioned: (how2recurse as not null).get_type(t)]
                return ir::make_union(self.builtins, types, ast::locate_type(union_type))

            case ast::GenericType generic_type:
                if not self.generics.has_key(generic_type.name):
                    print("no generic type named {generic_type.name}")
                    assert(false)  # TODO: error

                let generik = self.generics.get(generic_type.name)
                if how2recurse == null:
                    let args = [foreach a of generic_type.args: self.get_type(a, null)]
                else:
                    args = [foreach a of generic_type.args: (how2recurse as not null).get_type(a)]
                return self.builtins.generic2type(generik, args, generic_type.location)

    meth check_type_not_exists(Str name, Location location):
        if self.types.has_key(name) or self.typedef_laziness.has_key(name):
            location.error("type '{name}' already exists")

    # See docs/syntax.md
    # Step 1: available type names: imports, classes, typedefs, unions
    # Step 2: typedef contents, union contents
    # Step 3: function/method names and signatures, class constructor signatures
    # Step 4: function and method bodies

    meth do_step1(ast::ToplevelDeclaration top_declaration):
        switch top_declaration:
            case ast::Import imp:
                foreach symbol of self.symbols:
                    if symbol.path == imp.path:
                        let name = imp.name + "::" + symbol.name
                        switch symbol.value:
                            case ir::FileVariable var:
                                # Technically step 3, but adding earlier doesn't matter
                                self.add_var(var, name)
                            case ir::Type type:
                                # TODO: use check_type_not_exists?
                                assert(not self.types.has_key(name))
                                self.types.set(name, type)

            case ast::ClassDef classdef:
                let methods_to_create = ["to_string", "equals", "hash"]
                foreach method of classdef.body:
                    if method.name in methods_to_create:
                        methods_to_create.delete_only(method.name)

                # The auto-created hash assumes pointer equals(), aka not-user-defined equals()
                if "equals" not in methods_to_create and "hash" in methods_to_create:
                    methods_to_create.delete_only("hash")

                self.check_type_not_exists(classdef.name, classdef.location)
                let classtype = new ir::BasicType(
                    classdef.name, true, new Mapping[Str, auto](), new Mapping[Str, auto](),
                    null, null, self.path, methods_to_create
                )
                # TODO: cleanup_list shouldn't be in builtins
                self.builtins.cleanup_list.push(classtype)
                # TODO: use check_type_not_exists?
                assert(not self.types.has_key(classdef.name))
                self.types.set(classdef.name, classtype)

            case ast::TypeDef type_def:
                self.check_type_not_exists(type_def.name, type_def.location)
                self.typedef_laziness.set(type_def.name, type_def.type)

            case ast::FuncOrMethodDef _:
                # TODO: check not exists
                pass

    meth do_step2(ast::ToplevelDeclaration top_declaration):
        switch top_declaration:
            # TODO: copy pasta
            case ast::TypeDef def:
                let type = self.get_named_type(def.name)
                self.symbols.push(new ir::Symbol(self.path, def.name, type))
                switch type:
                    case ir::UnionType union_type:
                        # use typedef name in error messages
                        assert(union_type.custom_name == null)  # TODO: may fail
                        union_type.custom_name = def.name as Str | null
                    case *:
                        pass
            case ast::ClassDef def:
                self.symbols.push(new ir::Symbol(self.path, def.name, self.get_named_type(def.name)))
            case *:
                pass

    meth func_or_meth_step3(ast::FuncOrMethodDef def, ir::BasicType | null classtype):
        switch def.returntype:
            case ast::Type type:
                let returntype = self.get_type(type, null) as ir::Type | ir::NoReturn | null
            case ast::NoReturn _:
                returntype = new ir::NoReturn()
            case null _:
                returntype = null

        let functype = new ir::FunctionType(
            [foreach arg of def.args: self.get_type(arg.type, null)],
            returntype
        )
        if classtype == null:
            # TODO: use def.export
            let func_var = new ir::FileVariable(def.name, functype)
            self.symbols.push(new ir::Symbol(self.path, def.name, func_var))
            self.add_var(func_var, def.name)
        else:
            assert(not (classtype as not null).methods.has_key(def.name))
            (classtype as not null).methods.set(def.name, functype)

    meth do_step3(ast::ToplevelDeclaration top_declaration):
        switch top_declaration:
            case ast::FuncOrMethodDef funcdef:
                self.func_or_meth_step3(funcdef, null)

            case ast::ClassDef classdef:
                let classtype = self.types.get(classdef.name) as ir::BasicType
                foreach member of classdef.members:
                    assert(not classtype.members.has_key(member.name))
                    classtype.members.set(member.name, self.get_type(member.type, null))

                # TODO: is it possible to specify this when creating classtype?
                # TODO: auto types not working at all here
                classtype.constructor_argtypes = new List[ir::Type]() as List[ir::Type] | null
                (classtype.constructor_argtypes as not null).push_all([
                    foreach member of classdef.members: self.get_type(member.type, null)
                ])

                foreach method_def of classdef.body:
                    let self_location = classdef.location   # a bit weird
                    method_def.args.insert(0, new ast::TypeAndName(
                        new ast::NamedType(self_location, classtype.name),
                        "self",
                        self_location
                    ))
                    self.func_or_meth_step3(method_def, classtype)

            case *:
                pass

    meth func_or_meth_step4(
        ast::FuncOrMethodDef def, ir::Type | null classtype
    ) -> ir::ToplevelDeclaration:
        if classtype == null:
            let funcvar = self.get_var(def.name, null)
            let functype = ir::var_type(funcvar) as ir::FunctionType  # TODO: error
        else:
            functype = ir::get_method(classtype as not null, def.name, self.builtins)

        let local_vars = self.variables.copy()
        let argvars = []
        let body = []

        let local_var_counter = 0
        assert(def.args.length() == functype.argtypes.length())
        for let i = 0; i < def.args.length(); i = i+1:   # TODO: zip
            let argname = def.args.get(i).name
            let arg_location = def.args.get(i).name_location
            let type = functype.argtypes.get(i)

            local_var_counter = local_var_counter + 1
            let argvar = new ir::LocalVariable(type, local_var_counter, arg_location)
            argvars.push(argvar)

            # Copy arguments to separate local variables to allow assigning to arguments
            # TODO: is this necessary?
            let copied_var = new ir::LocalVariable(type, local_var_counter, arg_location)
            local_var_counter = local_var_counter + 1
            body.push(new ir::VarCpy(copied_var, argvar) as ir::Instruction)
            body.push(new ir::IncRef(copied_var))

            assert(not local_vars.has_key(argname))
            local_vars.set(argname, copied_var)

        # TODO: this sucks
        switch functype.returntype:
            case ir::Type rettype:
                let returntype_without_noreturn = rettype as ir::Type | null
            case *:
                returntype_without_noreturn = null

        let converter = new FunctionOrMethodConverter(
            self.builtins,
            self,
            local_vars,
            returntype_without_noreturn,
            [], [], [], new Mapping[ir::AutoType, ir::Type](), [],
            0, 0,
            local_var_counter,
        )
        foreach statement of def.body:
            converter.do_statement(statement)
        converter.get_rid_of_auto_everywhere()
        body.push_all(converter.code)

        if classtype == null:
            return new ir::FuncDef(funcvar as ir::FileVariable, argvars, body)
        else:
            #assert not def.export
            return new ir::MethodDef(def.name, functype, argvars, body)

    meth do_step4(ast::ToplevelDeclaration top_declaration) -> List[ir::ToplevelDeclaration]:
        switch top_declaration:
            case ast::ClassDef classdef:
                let classtype = self.types.get(classdef.name)
                return [
                    foreach method_def of classdef.body:
                        self.func_or_meth_step4(method_def, classtype)
                ]

            case ast::FuncOrMethodDef funcdef:
                return [self.func_or_meth_step4(funcdef, null)]

            case *:
                return []


export func convert_program(
    ir::Builtins builtins,
    List[ast::ToplevelDeclaration] program,
    Str path,
    List[ir::Symbol] symbols,
) -> List[ir::ToplevelDeclaration]:

    # TODO: mapping comprehensions
    # TODO: mapping copying doesn't work here
    let vars = new Mapping[Str, ir::Variable]()
    foreach item of builtins.visible_vars.items():
        vars.set(item.key, item.value)

    let types = new Mapping[Str, ir::Type]()
    foreach type of builtins.get_builtin_types():
        types.set(ir::type_name(type), type)

    let generics = new Mapping[Str, ir::Generic]()
    foreach generik of builtins.get_builtin_generics():
        generics.set(generik.name, generik)

    let converter = new FileConverter(builtins, path, symbols, types, generics, vars, new Mapping[Str, auto]())

    foreach top of program:
        converter.do_step1(top)
    foreach top of program:
        converter.do_step2(top)
    assert(converter.typedef_laziness == new Mapping[Str, auto]())
    foreach top of program:
        converter.do_step3(top)

    let result = []
    foreach top of program:
        result.push_all(converter.do_step4(top))
    return result
