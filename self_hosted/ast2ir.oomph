import "ast.oomph" as ast
import "error.oomph" as error
import "ir.oomph" as ir

# TODO: mappings and tuples
class NamedVariable(Str name, ir::Variable var)
class NamedType(Str name, ir::Type type)
class NamedGeneric(Str name, ir::Generic generik)
class LoopLabels(ir::GotoLabel continue_label, ir::GotoLabel break_label)
class AutoTypeResolve(ir::AutoType autotype, ir::Type actual)
class AutoTypePair(ir::AutoType first, ir::AutoType second)
class TypePair(ir::Type first, ir::Type second)
class NamedAstType(Str name, ast::Type type)
class NamedAstTypeList(Str name, List[ast::Type] types)


# TODO: shouldn't be needed
func is_autotype(ir::Type type) -> Bool:
    switch type:
        case ir::AutoType autotype:
            return true
        case *:
            return false

func find_variable(
    List[NamedVariable] variables,
    Str name,
    error::Location | null location,  # if user can make variable not found, then must be non-null
) -> ir::Variable:
    foreach named_var of variables:
        if named_var.name == name:
            return named_var.var
    location.get().error("variable not found: {name}")


class FunctionOrMethodConverter(
    ir::Builtins builtins,
    FileConverter file_converter,
    List[NamedVariable] variables,
    ir::Type | null returntype,
    List[LoopLabels] loop_stack,
    List[ir::Instruction] code,
    List[List[ir::Instruction]] code_stack,
    List[AutoTypeResolve] resolved_autotypes,
    List[AutoTypePair] matching_autotypes,
    Int autotype_counter,
    Int goto_label_counter,
    Int local_var_counter,
):
    meth create_var(ir::Type type, error::Location location) -> ir::LocalVariable:
        self.local_var_counter = self.local_var_counter + 1
        let result = new ir::LocalVariable(type, self.local_var_counter, location)

        # Newly created variables must be decreffed, in case we are in a loop.
        # Also, after decreffing, make sure that another iteration of loop
        # won't decref the same variable again.
        self.code.push(new ir::DecRef(result))
        self.code.push(new ir::UnSet(result))
        return result

    meth get_var(Str name, error::Location | null location) -> ir::Variable:
        return find_variable(self.variables, name, location)

    meth get_matching_autotype_list(ir::AutoType autotype) -> List[ir::AutoType]:
        # TODO: transitivity? if (A,B) and (B,C) in matching_autotypes then A --> [A,B,C]
        let matches = [autotype]
        foreach pair of self.matching_autotypes:
            if pair.first == autotype and pair.second not in matches:
                matches.push(pair.second)
            if pair.second == autotype and pair.first not in matches:
                matches.push(pair.first)
        return matches

    meth resolve_autotype(ir::AutoType autotype, ir::Type actual):
        switch actual:
            case ir::AutoType _:
                assert(false)
            case *:
                pass

        foreach pair of self.resolved_autotypes:
            if pair.autotype == autotype:
                assert(pair.actual == actual)
                return

        foreach matching of self.get_matching_autotype_list(autotype):
            self.resolved_autotypes.push(new AutoTypeResolve(matching, actual))

    meth substitute_autotypes(ir::Type type, Bool must_succeed) -> ir::Type:
        switch type:
            case ir::AutoType autotype:
                foreach resolve of self.resolved_autotypes:
                    if resolve.autotype == autotype:
                        return resolve.actual
                assert(not must_succeed)
                # TODO: Return exactly one of all matching autotypes consistently
                #return min(self.get_matching_autotype_list(type), key=id)
                return type
            case *:
                pass

        let source = ir::get_generic_source(type)
        if source == null:
            return type

        let arg = self.substitute_autotypes(source.get().arg, must_succeed)
        return self.builtins.generic2type(source.get().generik, arg)

    meth create_autotype() -> ir::AutoType:
        self.autotype_counter = self.autotype_counter + 1
        return new ir::AutoType(self.autotype_counter)

    meth create_goto_label() -> ir::GotoLabel:
        self.goto_label_counter = self.goto_label_counter + 1
        return new ir::GotoLabel(self.goto_label_counter)

    meth get_type(ast::Type raw_type) -> ir::Type:
        switch raw_type:
            case ast::AutoType autotype:
                return self.create_autotype()
            case *:
                return self.file_converter.get_type(raw_type, self)

    # TODO: something like @contextlib.contextmanager in python?
    meth push_code():
        self.code_stack.push(self.code)
        self.code = new List[ir::Instruction]()  # FIXME: auto types not work

    meth pop_code() -> List[ir::Instruction]:
        let result = self.code
        self.code = self.code_stack.pop()
        return result

    meth stringify(ir::LocalVariable var) -> ir::LocalVariable:
        if var.type == self.builtins.STR:
            return var

        let result_var = self.create_var(self.builtins.STR, var.location)
        self.code.push(new ir::MethodCall(
            var, "to_string", [], result_var, var.location
        ))
        return result_var

    meth create_special_call(Str name, List[ir::LocalVariable] args) -> ir::LocalVariable:
        # Not perfect, but doesn't matter much
        let location = args.first().location
        foreach arg of args.slice(1, args.length()):
            location = location.combine(arg.location)

        let function = self.builtins.get_hidden_var(name)
        let result_var = self.create_var(
            (function.type as ir::FunctionType).returntype as ir::Type,
            location
        )
        self.code.push(new ir::FunctionCall(function, args, result_var))
        return result_var

    meth lookup_autotype(ir::AutoType autotype) -> ir::Type | null:
        foreach resolve of self.resolved_autotypes:
            if resolve.autotype == autotype:
                return resolve.actual
        return null

    meth do_the_autotype_thing(ir::Type type1, ir::Type type2) -> TypePair:
        if is_autotype(type1) and is_autotype(type2):
            if type1 != type2:
                let actual_type1 = self.lookup_autotype(type1 as ir::AutoType)
                let actual_type2 = self.lookup_autotype(type2 as ir::AutoType)
                if actual_type1 != null and actual_type2 != null:
                    return new TypePair(actual_type1.get(), actual_type2.get())
                if actual_type1 != null:
                    return new TypePair(actual_type1.get(), type2)
                if actual_type2 != null:
                    return new TypePair(type1, actual_type2.get())

                self.matching_autotypes.push(new AutoTypePair(type1 as ir::AutoType, type2 as ir::AutoType))
                # TODO: should be consistent with substitute_autotypes?
                return new TypePair(type1, type1)

        elif is_autotype(type1):
            let resolved = self.lookup_autotype(type1 as ir::AutoType)
            if resolved != null:
                return new TypePair(resolved.get(), type2)
            self.resolve_autotype(type1 as ir::AutoType, type2)
            return new TypePair(type2, type2)

        elif is_autotype(type2):
            let resolved = self.lookup_autotype(type2 as ir::AutoType)
            if resolved != null:
                return new TypePair(type1, resolved.get())
            self.resolve_autotype(type2 as ir::AutoType, type1)
            return new TypePair(type1, type1)

        else:
            let type1_source = ir::get_generic_source(type1)
            let type2_source = ir::get_generic_source(type2)
            if (
                type1_source != null
                and type2_source != null
                and type1_source.get().generik == type2_source.get().generik
            ):
                # Handle List[Str] matching List[auto]
                let generik = type1_source.get().generik
                let arg_pair = self.do_the_autotype_thing(type1_source.get().arg, type2_source.get().arg)
                return new TypePair(
                    self.builtins.generic2type(generik, arg_pair.first),
                    self.builtins.generic2type(generik, arg_pair.second),
                )

        return new TypePair(type1, type2)

    meth implicit_conversion_if_possible(
        ir::LocalVariable var,
        ir::Type target_type,
    ) -> ir::LocalVariable | null:
        let pair = self.do_the_autotype_thing(var.type, target_type)
        var.type = pair.first
        target_type = pair.second

        if var.type == target_type:
            return var

        if target_type == self.builtins.FLOAT and var.type == self.builtins.INT:
            return self.create_special_call("int2float", [var])

        switch target_type:
            case ir::UnionType target_union:
                # FIXME: cyclicly nested unions
                # TODO: simplify the spec plz
                let result_path = new (List[ir::UnionType] | null)(null)
                let todo_paths = [[target_union]]
                while todo_paths != []:
                    let path = todo_paths.pop()
                    foreach member of path.last().type_members:
                        if member == var.type:
                            if result_path != null:
                                # ambiguous implicit conversion
                                return null
                            result_path = path
                        else:
                            switch member:
                                case ir::UnionType member_union:
                                    let copy = path.reversed().reversed()  # FIXME lol
                                    copy.push(member_union)
                                    todo_paths.push(copy)
                                case *:
                                    pass

                if result_path == null:
                    return null

                foreach union_type of result_path.get().reversed():
                    let new_var = self.create_var(union_type, var.location)
                    self.code.push(new ir::InstantiateUnion(new_var, var))
                    self.code.push(new ir::IncRef(var))
                    var = new_var
                return var
            case *:
                return null

    meth implicit_conversion(ir::LocalVariable var, ir::Type type) -> ir::LocalVariable:
        let result = self.implicit_conversion_if_possible(var, type)
        if result == null:
            var.location.error(
                "wrong type: should be {ir::type_name(type)}, but it's {ir::type_name(var.type)}"
            )
        return result.get()

    # Can be called multiple times, that doesn't matter
    meth do_args(
        List[ir::LocalVariable] args,
        List[ir::Type] target_types,
        error::Location func_location,
    ) -> List[ir::LocalVariable]:
        if args.length() != target_types.length():
            if target_types.length() == 1:
                let s = ""
            else:
                s = "s"
            func_location.error("expected {target_types.length()} argument{s}, got {args.length()}")

        # TODO: zip
        return [
            for let i = 0; i < args.length(); i = i+1:
            self.implicit_conversion(args.get(i), target_types.get(i))
        ]

    # TODO: get rid of this
    meth get_method_functype(ir::Type type, Str name) -> ir::FunctionType:
        return ir::get_method(type, name, self.builtins)

    # TODO: get rid of this
    meth get_attribute_type(ir::Type type, Str attribute) -> ir::Type:
        return ir::get_member(type, attribute)

    meth do_call(ast::Call call, Bool must_return_value) -> ir::LocalVariable | null:
        let args = [foreach arg of call.args: self.do_expression(arg)]
        let result_var = new (ir::LocalVariable | null)(null)

        switch call.function:
            case ast::GetAttribute method:
                let self_var = self.do_expression(method.obj)

                self_var.type = self.substitute_autotypes(self_var.type, false)
                switch self_var.type:
                    case ir::AutoType self_autotype:
                        # Less type information available, do_args will be called later
                        if must_return_value:
                            result_var = self.create_var(self.create_autotype(), call.location)
                    case *:
                        let functype = self.get_method_functype(self_var.type, method.attribute)
                        assert(self_var.type == functype.argtypes.first())

                        switch functype.returntype:
                            case ir::Type typ:
                                result_var = self.create_var(typ, call.location)
                            case *:
                                pass

                        args = self.do_args(
                            args,
                            functype.argtypes.slice(1, functype.argtypes.length()),
                            call.location
                        )
                self.code.push(new ir::MethodCall(
                    self_var, method.attribute, args, result_var, call.location
                ))

            case ast::GetVar ast_function:
                let function = self.get_var(ast_function.varname, ast_function.location)
                let functype = ir::var_type(function) as ir::FunctionType

                switch functype.returntype:
                    case ir::Type typ:
                        result_var = self.create_var(typ, call.location)
                    case *:
                        pass

                if function == self.builtins.get_visible_var("print"):
                    if args.length() != 1:
                        ast_function.location.error("print must be called with 1 argument")
                    args = [foreach arg of args: self.stringify(arg)]
                else:
                    if function == self.builtins.get_visible_var("assert"):
                        if args.length() != 1:
                            ast_function.location.error("assert must be called with 1 argument")
                        # Add path and line number args
                        let loc = ast_function.location
                        args.push(self.do_expression(new ast::StringConstant(loc, loc.path)))
                        args.push(self.do_expression(new ast::IntConstant(loc, loc.lineno)))
                    args = self.do_args(
                        args,
                        functype.argtypes,
                        ast_function.location,
                    )
                self.code.push(new ir::FunctionCall(function, args, result_var))

            case ast::Constructor constructor:
                # TODO: is this special-casing really needed?
                let the_class = self.get_type(constructor.type)
                args = self.do_args(
                    args,
                    ir::get_constructor_argtypes(the_class).get(),  # TODO: error
                    constructor.location,
                )
                result_var = self.create_var(the_class, call.location)
                self.code.push(new ir::ConstructorCall(result_var.get(), args))

            case *:
                assert(false)

        return result_var


    meth not_(ir::LocalVariable obj) -> ir::LocalVariable:
        return self.create_special_call("bool_not", [obj])

    meth bool_constant(Str which, error::Location location) -> ir::LocalVariable:
        let result = self.create_var(self.builtins.BOOL, location)
        self.code.push(new ir::VarCpy(result, self.builtins.get_visible_var("true")))
        return result

    meth do_binary_op_typed(ir::LocalVariable lhs, Str op, error::Location op_location, ir::LocalVariable rhs) -> ir::LocalVariable:
        if op in ["in", "not in"]:
            let result_var = self.create_var(self.builtins.BOOL, op_location)
            self.code.push(new ir::MethodCall(
                rhs, "__contains", [lhs], result_var, op_location
            ))
            if op == "not in":
                return self.not_(result_var)
            return result_var

        # See docs/implicit-conversions.md
        if lhs.type != rhs.type:
            let new_lhs = self.implicit_conversion_if_possible(lhs, rhs.type)
            let new_rhs = self.implicit_conversion_if_possible(rhs, lhs.type)
            if new_lhs == null and new_rhs != null:
                rhs = new_rhs.get()
            elif new_lhs != null and new_rhs == null:
                lhs = new_lhs.get()

        assert(self.substitute_autotypes(lhs.type, false) == self.substitute_autotypes(rhs.type, false))
        let type = self.substitute_autotypes(lhs.type, false)

        if op == "!=":
            return self.not_(self.do_binary_op_typed(lhs, "==", op_location, rhs))

        # Reduce >=, <=, and < to use >
        if op == "<":
            return self.do_binary_op_typed(rhs, ">", op_location, lhs)
        if op == "<=":
            return self.not_(self.do_binary_op_typed(lhs, ">", op_location, rhs))
        if op == ">=":
            return self.not_(self.do_binary_op_typed(lhs, "<", op_location, rhs))

        if type == self.builtins.STR and op == "+":
            # TODO: add something to make a+b+c more efficient than (a+b)+c
            return self.create_special_call("string_concat", [lhs, rhs])

        if type == self.builtins.INT and op == "+":
            return self.create_special_call("int_add", [lhs, rhs])
        if type == self.builtins.INT and op == "-":
            return self.create_special_call("int_sub", [lhs, rhs])
        if type == self.builtins.INT and op == "*":
            return self.create_special_call("int_mul", [lhs, rhs])
        if type == self.builtins.INT and op == "mod":
            return self.create_special_call("int_mod", [lhs, rhs])
        if type == self.builtins.INT and op == ">":
            return self.create_special_call("int_gt", [lhs, rhs])

        if type == self.builtins.INT and op == "/":
            lhs = self.create_special_call("int2float", [lhs])
            rhs = self.create_special_call("int2float", [rhs])
            type = self.builtins.FLOAT

        if type == self.builtins.FLOAT and op == "+":
            return self.create_special_call("float_add", [lhs, rhs])
        if type == self.builtins.FLOAT and op == "-":
            return self.create_special_call("float_sub", [lhs, rhs])
        if type == self.builtins.FLOAT and op == "*":
            return self.create_special_call("float_mul", [lhs, rhs])
        if type == self.builtins.FLOAT and op == "/":
            return self.create_special_call("float_div", [lhs, rhs])
        if type == self.builtins.FLOAT and op == "mod":
            return self.create_special_call("float_mod", [lhs, rhs])
        if type == self.builtins.FLOAT and op == ">":
            return self.create_special_call("float_gt", [lhs, rhs])

        if op == "==":
            result_var = self.create_var(self.builtins.BOOL, op_location)
            self.code.push(new ir::MethodCall(lhs, "equals", [rhs], result_var, op_location))
            return result_var

        print("wrong types: {ir::type_name(type)} {op} {ir::type_name(type)}")
        assert(false)  # TODO: error

    meth do_if(ir::LocalVariable cond, List[ir::Instruction] then, List[ir::Instruction] otherwise):
        let then_label = self.create_goto_label()
        let done_label = self.create_goto_label()
        self.code.push(new ir::GotoIf(then_label, cond))
        self.code.push_all(otherwise)
        self.code.push(new ir::GotoIf(done_label, self.bool_constant("true", cond.location)))
        self.code.push(then_label)
        self.code.push_all(then)
        self.code.push(done_label)

    meth do_binary_op(ast::BinaryOperator op_ast) -> ir::LocalVariable:
        # Avoid evaluating right side when not needed
        # TODO: mention this in docs
        if op_ast.op in ["and", "or"]:
            let lhs_var = self.do_expression_and_convert(op_ast.lhs, self.builtins.BOOL)
            let result_var = self.create_var(self.builtins.BOOL, op_ast.location)

            self.push_code()
            let rhs_var = self.do_expression_and_convert(op_ast.rhs, self.builtins.BOOL)
            let rhs_evaluation = self.pop_code()
            rhs_evaluation.push(new ir::VarCpy(result_var, rhs_var))

            if op_ast.op == "and":
                self.do_if(
                    lhs_var,
                    rhs_evaluation,
                    [
                        new ir::Instruction(new ir::VarCpy(
                            result_var, self.builtins.get_visible_var("false")
                        ))
                    ],
                )
            else:
                self.do_if(
                    lhs_var,
                    [
                        new ir::Instruction(new ir::VarCpy(
                            result_var, self.builtins.get_visible_var("true")
                        ))
                    ],
                    rhs_evaluation,
                )
            return result_var

        let lhs = self.do_expression(op_ast.lhs)
        let rhs = self.do_expression(op_ast.rhs)
        return self.do_binary_op_typed(lhs, op_ast.op, op_ast.location, rhs)

    # Always returns new variable
    meth do_expression(ast::Expression expr) -> ir::LocalVariable:
        let location = ast::locate_expression(expr)

        switch expr:
            case ast::IntConstant int:
                # This accepts int64_t values only, because the value has already been converted to int
                let var = self.create_var(self.builtins.INT, location)
                self.code.push(new ir::IntConstant(int.value, var))
                return var

            case ast::FloatConstant float:
                let var = self.create_var(self.builtins.FLOAT, location)
                self.code.push(new ir::FloatConstant(float.value, var))
                return var

            case ast::StringConstant string:
                let var = self.create_var(self.builtins.STR, location)
                self.code.push(new ir::StringConstant(string.value, var))
                return var

            case ast::ListLiteral list:
                let content = [foreach expr of list.content: self.do_expression(expr)]
                if content == []:
                    let content_type = new ir::Type(self.create_autotype())
                else:
                    content_type = content.first().type
                    foreach member of content:
                        assert(member.type == content_type)  # TODO: error

                let list_var = self.create_var(
                    self.builtins.generic2type(self.builtins.LIST, content_type), location
                )
                self.code.push(new ir::ConstructorCall(list_var, []))
                foreach item_var of content:
                    self.code.push(new ir::MethodCall(
                        list_var, "push", [item_var], null, location
                    ))
                return list_var

            case ast::StringFormatJoin join:
                assert(join.parts.length() >= 2)
                let result = self.stringify(self.do_expression(join.parts.first()))
                foreach part of join.parts.slice(1, join.parts.length()):
                    # TODO: this results in slow nested code
                    result = self.create_special_call(
                        "string_concat", [result, self.stringify(self.do_expression(part))]
                    )
                return result

            case ast::Call call:
                # FIXME: nested switches suck
                switch call.function:
                    case ast::Constructor constructor:
                        switch self.get_type(constructor.type):
                            case ir::UnionType union_type:
                                assert(call.args.length() == 1)  # TODO: error
                                let obj = self.do_expression(call.args.first())
                                return self.implicit_conversion(obj, union_type)
                            case *:
                                pass
                    case *:
                        pass

                return self.do_call(call, true).get()

            case ast::GetVar getvar:
                # Don't return the same variable, otherwise 'a = a' decrefs too much
                # Also ensure we always return LocalVariable
                let old_var = self.get_var(getvar.varname, location)
                let new_var = self.create_var(ir::var_type(old_var), location)
                self.code.push(new ir::VarCpy(new_var, old_var))
                self.code.push(new ir::IncRef(new_var))
                return new_var

            case ast::UnaryOperator unary:
                let obj = self.do_expression(unary.obj)
                if unary.op == "not":
                    return self.create_special_call("bool_not", [
                        self.implicit_conversion(obj, self.builtins.BOOL)
                    ])
                # TODO: auto type support (remember docs)
                if obj.type == self.builtins.INT and unary.op == "-":
                    return self.create_special_call("int_neg", [obj])
                if obj.type == self.builtins.FLOAT and unary.op == "-":
                    return self.create_special_call("float_neg", [obj])
                # TODO: error
                print("wrong types: {unary.op}{ir::type_name(obj.type)}")
                assert(false)

            case ast::BinaryOperator binary:
                return self.do_binary_op(binary)

            case ast::GetAttribute getattr:
                let obj = self.do_expression(getattr.obj)
                obj.type = self.substitute_autotypes(obj.type, false)
                switch obj.type:
                    case ir::AutoType autotype:
                        let result = self.create_var(
                            self.create_autotype(), location
                        )
                    case *:
                        result = self.create_var(
                            self.get_attribute_type(obj.type, getattr.attribute),
                            location
                        )
                self.code.push(new ir::GetAttribute(obj, result, getattr.attribute))
                self.code.push(new ir::IncRef(result))
                return result

            case ast::StatementsAndExpression sae:
                foreach s of sae.statements:
                    self.do_statement(s)
                return self.do_expression(sae.expression)

            case ast::As ass:
                let lhs = self.do_expression(ass.expr)
                let result = self.create_var(self.get_type(ass.type), location)
                self.code.push(new ir::GetFromUnion(result, lhs))
                self.code.push(new ir::IncRef(result))
                return result

            case ast::Constructor _:
                # TODO: constructor functions as first-class objects
                assert(false)

            # If these cases happen, then ast_transformer hasn't done its job:
            case ast::Parenthesized _:
                assert(false)
            case ast::ListComprehension _:
                assert(false)

    meth do_expression_and_convert(ast::Expression expr, ir::Type type) -> ir::LocalVariable:
        return self.implicit_conversion(self.do_expression(expr), type)

    meth do_statement(ast::Statement stmt):
        switch stmt:
            case ast::Call call:
                self.do_call(call, false)

            case ast::Let leet:
                # TODO: better way to filter list
                # TODO: document the shadowing/replacing behaviour
                let old_vars = self.variables
                self.variables = [new NamedVariable(leet.varname, self.do_expression(leet.value))]
                foreach named_var of old_vars:
                    if named_var.name != leet.varname:
                        self.variables.push(named_var)

            case ast::SetVar setvar:
                let var = self.get_var(setvar.varname, setvar.location) as ir::LocalVariable  # TODO: error
                let new_value_var = self.do_expression(setvar.value)
                self.code.push(new ir::DecRef(var))
                self.code.push(
                    new ir::VarCpy(var, self.implicit_conversion(new_value_var, var.type))
                )
                self.code.push(new ir::IncRef(var))

            case ast::SetAttribute setattr:
                let obj = self.do_expression(setattr.obj)
                let new_value_var = self.do_expression(setattr.value)

                # TODO: error
                assert(ir::get_member(obj.type, setattr.attribute) == new_value_var.type)

                # Copy old value into local var, so that it will be decreffed
                let old_value_var = self.create_var(new_value_var.type, setattr.attribute_location)
                self.code.push(new ir::GetAttribute(obj, old_value_var, setattr.attribute))
                self.code.push(new ir::SetAttribute(obj, setattr.attribute, new_value_var))
                self.code.push(new ir::IncRef(new_value_var))

            case ast::Pass p:
                pass

            case ast::Continue cont:
                let label = self.loop_stack.last().continue_label
                self.code.push(new ir::GotoIf(label, self.bool_constant("true", cont.location)))

            case ast::Break bread:
                let label = self.loop_stack.last().break_label
                self.code.push(new ir::GotoIf(label, self.bool_constant("true", bread.location)))

            case ast::Return ret:
                if self.returntype == null:
                    assert(ret.value == null)  # TODO: error
                    self.code.push(new ir::Return(null))
                else:
                    # TODO: improve error for missing return value
                    # TODO: error for missing return statement
                    self.code.push(new ir::Return(self.do_expression_and_convert(
                        ret.value.get(), self.returntype.get(),
                    )))

            case ast::If if_statement:
                let untyped_condition = if_statement.ifs_and_elifs.first().cond
                let untyped_body = if_statement.ifs_and_elifs.first().body
                let condition = self.do_expression_and_convert(untyped_condition, self.builtins.BOOL)
                let body = self.do_block(untyped_body)

                if if_statement.ifs_and_elifs.length() >= 2:
                    let otherwise = self.do_block([
                        new ast::Statement(new ast::If(
                            if_statement.ifs_and_elifs.slice(1, if_statement.ifs_and_elifs.length()),
                            if_statement.else_block,
                        ))
                    ])
                else:
                    otherwise = self.do_block(if_statement.else_block)
                self.do_if(condition, body, otherwise)

            case ast::Loop loop:
                let cond_label = self.create_goto_label()
                let continue_label = self.create_goto_label()
                let break_label = self.create_goto_label()

                let header = loop.loop_header as ast::ForLoopHeader

                foreach init of header.init:
                    self.do_statement(init)

                self.code.push(cond_label)
                if header.cond == null:
                    let cond_var = self.create_var(
                        self.builtins.BOOL, header.keyword_location
                    )
                    self.code.push(new ir::VarCpy(
                        cond_var, self.builtins.get_visible_var("true")
                    ))
                else:
                    cond_var = self.do_expression_and_convert(header.cond.get(), self.builtins.BOOL)
                self.code.push(new ir::GotoIf(break_label, self.not_(cond_var)))

                self.loop_stack.push(new LoopLabels(continue_label, break_label))
                self.code.push_all(self.do_block(loop.body))
                let popped = self.loop_stack.pop()
                assert(popped.continue_label == continue_label)
                assert(popped.break_label == break_label)

                self.code.push(continue_label)
                foreach incr of header.incr:
                    self.do_statement(incr)
                self.code.push(new ir::GotoIf(
                    cond_label,
                    self.bool_constant("true", ast::locate_loop_header(loop.loop_header))
                ))
                self.code.push(break_label)

                if header.init.length() == 1:
                    switch header.init.first():
                        case ast::Let leet:
                            let varnames = [foreach var of self.variables: var.name]
                            if leet.varname in varnames:
                                self.variables.delete_at_index(varnames.find_only(leet.varname))
                        case *:
                            pass

            case ast::Switch switchie:
                let union_var = self.do_expression(switchie.union_obj)
                let union_type = union_var.type as ir::UnionType

                # TODO: better way to copy list
                let types_to_do = union_type.type_members.reversed().reversed()

                let done_label = self.create_goto_label()
                let member_check = self.create_var(self.builtins.BOOL, switchie.location)
                let cases = new List[ir::Instruction]()

                foreach chase of switchie.cases:
                    let label = self.create_goto_label()
                    cases.push(label)

                    if chase.type_and_name == null:
                        assert(types_to_do != [])
                        let nice_types = types_to_do
                        types_to_do = []
                    else:
                        let varname = chase.type_and_name.get().name
                        let nice_type = self.get_type(chase.type_and_name.get().type)
                        nice_types = [nice_type]
                        assert(nice_type in types_to_do)   # TODO: error
                        types_to_do.delete_only(nice_type)

                        let case_var = self.create_var(
                            nice_type, chase.type_and_name.get().name_location
                        )
                        # TODO: assert varname not in self.variables
                        self.variables.push(new NamedVariable(varname, case_var))
                        cases.push(new ir::GetFromUnion(case_var, union_var))
                        cases.push(new ir::IncRef(case_var))

                    cases.push_all(self.do_block(chase.body))
                    cases.push(new ir::GotoIf(done_label, self.bool_constant("true", chase.location)))

                    if chase.type_and_name != null:
                        assert(self.get_var(varname, null) == case_var)
                        # TODO: better way to remove from list, with custom key func
                        for let i = 0; ; i = i + 1:
                            if self.variables.get(i).name == varname and self.variables.get(i).var == case_var:
                                self.variables.delete_at_index(i)
                                break

                    foreach type of nice_types:
                        self.code.push(new ir::UnionMemberCheck(member_check, union_var, type))
                        self.code.push(new ir::GotoIf(label, member_check))

                if types_to_do != []:
                    print("switch does not handle: {types_to_do}")
                    assert(false)

                # TODO: add panic to self.code to run when no union members matched
                self.code.push_all(cases)
                self.code.push(done_label)

    meth do_block(List[ast::Statement] block) -> List[ir::Instruction]:
        self.push_code()
        foreach stmt of block:
            self.do_statement(stmt)
        return self.pop_code()

    meth get_rid_of_auto_in_var(ir::Variable var):
        switch var:
            case ir::LocalVariable local_var:
                local_var.type = self.substitute_autotypes(local_var.type, true)
            case *:
                pass

    meth get_rid_of_auto_everywhere():
        # Method calls can happen before the type is known. Here we assume that
        # the types got figured out.
        foreach ins of self.code.reversed().reversed():   # TODO: better way to copy list
            switch ins:
                case ir::MethodCall call:
                    self.get_rid_of_auto_in_var(call.obj)
                    let functype = self.get_method_functype(call.obj.type, call.method_name)

                    self.push_code()
                    call.args = self.do_args(
                        call.args,
                        functype.argtypes.slice(1, functype.argtypes.length()),
                        call.location
                    )
                    let front_code = self.pop_code()

                    let i = self.code.find_only(call)
                    # TODO: insert_sublist method to handle this
                    foreach item of front_code.reversed():
                        self.code.insert(i, item)

                    if functype.returntype == null:
                        # TODO: is this needed? when does it run?
                        assert(call.result == null)
                    elif call.result != null:
                        switch call.result.get().type:
                            case ir::AutoType autotype:
                                self.resolve_autotype(autotype, functype.returntype as ir::Type)
                            case *:
                                self.get_rid_of_auto_in_var(call.result.get())

                    foreach arg of call.args:
                        self.get_rid_of_auto_in_var(arg)

                case ir::GetAttribute getattr:
                    self.get_rid_of_auto_in_var(getattr.obj)
                    switch getattr.result.type:
                        case ir::AutoType autotype:
                            self.resolve_autotype(
                                autotype,
                                self.get_attribute_type(getattr.obj.type, getattr.attribute))
                        case *:
                            self.get_rid_of_auto_in_var(getattr.result)

                case *:
                    pass

        foreach ins of self.code:
            switch ins:
                # TODO: combining multiple cases together
                case ir::IncRef ins2:
                    self.get_rid_of_auto_in_var(ins2.var)
                case ir::DecRef ins2:
                    self.get_rid_of_auto_in_var(ins2.var)
                case ir::UnSet ins2:
                    self.get_rid_of_auto_in_var(ins2.var)
                case ir::IntConstant ins2:
                    self.get_rid_of_auto_in_var(ins2.var)
                case ir::FloatConstant ins2:
                    self.get_rid_of_auto_in_var(ins2.var)
                case ir::StringConstant ins2:
                    self.get_rid_of_auto_in_var(ins2.var)

                case ir::MethodCall call:
                    pass  # done separately above

                case ir::ConstructorCall call:
                    self.get_rid_of_auto_in_var(call.result)
                    foreach arg of call.args:
                        self.get_rid_of_auto_in_var(arg)

                case ir::FunctionCall call:
                    if call.result != null:
                        self.get_rid_of_auto_in_var(call.result.get())
                    self.get_rid_of_auto_in_var(call.function)
                    foreach arg of call.args:
                        self.get_rid_of_auto_in_var(arg)

                case ir::VarCpy varcpy:
                    self.get_rid_of_auto_in_var(varcpy.dest)
                    self.get_rid_of_auto_in_var(varcpy.source)

                case ir::GotoIf goto:
                    self.get_rid_of_auto_in_var(goto.cond)

                case ir::Return ret:
                    if ret.value != null:
                        self.get_rid_of_auto_in_var(ret.value.get())

                case ir::InstantiateUnion instantiate:
                    self.get_rid_of_auto_in_var(instantiate.result)
                    self.get_rid_of_auto_in_var(instantiate.value)

                case ir::GetAttribute getattr:
                    self.get_rid_of_auto_in_var(getattr.result)
                    self.get_rid_of_auto_in_var(getattr.obj)

                case ir::SetAttribute setattr:
                    self.get_rid_of_auto_in_var(setattr.value)
                    self.get_rid_of_auto_in_var(setattr.obj)

                case ir::GetFromUnion get:
                    self.get_rid_of_auto_in_var(get.result)
                    self.get_rid_of_auto_in_var(get.union_var)

                case ir::UnionMemberCheck member_check:
                    self.get_rid_of_auto_in_var(member_check.result)
                    self.get_rid_of_auto_in_var(member_check.union_var)

                case ir::PointersEqual pointer_check:
                    self.get_rid_of_auto_in_var(pointer_check.lhs)
                    self.get_rid_of_auto_in_var(pointer_check.rhs)
                    self.get_rid_of_auto_in_var(pointer_check.result)

                case ir::GotoLabel label:
                    pass


# TODO: do this in c
func create_pointers_equal_method(ir::Builtins builtins, ir::Type classtype, error::Location location) -> ir::MethodDef:
    let self_var = new ir::LocalVariable(classtype, 0, location)
    let other_var = new ir::LocalVariable(classtype, 1, location)
    let result_var = new ir::LocalVariable(builtins.BOOL, 2, location)
    return new ir::MethodDef(
        "equals",
        ir::get_method(classtype, "equals", builtins),
        [self_var, other_var],
        [
            new ir::Instruction(new ir::PointersEqual(self_var, other_var, result_var)),
            new ir::Instruction(new ir::Return(result_var)),
        ]
    )


class FileConverter(
    ir::Builtins builtins,
    Str path,
    List[ir::Symbol] symbols,
    List[NamedType] types,
    List[NamedGeneric] generics,
    List[NamedVariable] variables,
    List[NamedAstType] typedef_laziness,
):
    meth add_var(ir::Variable var, Str name):
        foreach named_var of self.variables:
            assert(named_var.name != name)
        self.variables.push(new NamedVariable(name, var))

    meth get_var(Str name, error::Location | null location) -> ir::Variable:
        return find_variable(self.variables, name, location)

    meth get_named_type(Str name) -> ir::Type:
        # step 2 stuff
        # TODO: better list methods
        let laziness_names = [foreach pair of self.typedef_laziness: pair.name]
        if name in laziness_names:
            let pair = self.typedef_laziness.delete_at_index(laziness_names.find_only(name))
            assert(name not in [foreach t of self.types: t.name])
            self.types.push(new NamedType(name, self.get_type(pair.type, null)))

        foreach type of self.types:
            if type.name == name:
                return type.type
        print("no type named '{name}'")
        assert(false)   # TODO: error

    # TODO: simplify how2recurse stuff
    meth get_type(ast::Type raw_type, FunctionOrMethodConverter | null how2recurse) -> ir::Type:
        switch raw_type:
            case ast::AutoType autotype:
                # TODO: test this
                autotype.location.error("can't use auto type here")

            case ast::NamedType named_type:
                return self.get_named_type(named_type.name)

            case ast::UnionType union_type:
                if how2recurse == null:
                    let types = [foreach t of union_type.unioned: self.get_type(t, null)]
                else:
                    types = [foreach t of union_type.unioned: how2recurse.get().get_type(t)]
                return ir::make_union(self.builtins, types, ast::locate_type(union_type))

            case ast::GenericType generic_type:
                foreach named_generic of self.generics:
                    if named_generic.name == generic_type.name:
                        if how2recurse == null:
                            let arg = self.get_type(generic_type.arg, null)
                        else:
                            arg = how2recurse.get().get_type(generic_type.arg)
                        return self.builtins.generic2type(named_generic.generik, arg)
                print("no generic type named {generic_type.name}")
                assert(false)  # TODO: error

    meth check_type_not_exists(Str name, error::Location location):
        if (
            name in [foreach t of self.types: t.name]
            or name in [foreach t of self.typedef_laziness: t.name]
        ):
            location.error("type '{name}' already exists")

    # See docs/syntax.md
    # Step 1: available type names: imports, classes, typedefs, unions
    # Step 2: typedef contents, union contents
    # Step 3: function/method names and signatures, class constructor signatures
    # Step 4: function and method bodies

    meth do_step1(ast::ToplevelDeclaration top_declaration):
        switch top_declaration:
            case ast::Import imp:
                foreach symbol of self.symbols:
                    if symbol.path == imp.path:
                        let name = imp.name + "::" + symbol.name
                        switch symbol.value:
                            case ir::FileVariable var:
                                # Technically step 3, but adding earlier doesn't matter
                                self.add_var(var, name)
                            case ir::Type type:
                                assert(name not in [foreach t of self.types: t.name])
                                self.types.push(new NamedType(name, type))

            case ast::ClassDef classdef:
                self.check_type_not_exists(classdef.name, classdef.location)
                let add_to_string_method = "to_string" not in [foreach method of classdef.body: method.name]
                let classtype = new ir::BasicType(
                    classdef.name, true, [], [], null, null, self.path, add_to_string_method
                )
                # TODO: cleanup_list shouldn't be in builtins
                self.builtins.cleanup_list.push(classtype)
                assert(classdef.name not in [foreach t of self.types: t.name])
                self.types.push(new NamedType(classdef.name, classtype))

            case ast::TypeDef type_def:
                self.check_type_not_exists(type_def.name, type_def.location)
                self.typedef_laziness.push(new NamedAstType(type_def.name, type_def.type))

            case ast::FuncOrMethodDef funcdef:
                # TODO: check not exists
                pass

    meth do_step2(ast::ToplevelDeclaration top_declaration):
        switch top_declaration:
            # TODO: copy pasta
            case ast::TypeDef def:
                let the_type = self.get_named_type(def.name)
                self.symbols.push(new ir::Symbol(self.path, def.name, the_type))
                switch the_type:
                    case ir::UnionType union_type:
                        # use typedef name in error messages
                        assert(union_type.custom_name == null)
                        union_type.custom_name = new (Str | null)(def.name)
                    case *:
                        pass
            case ast::ClassDef def:
                self.symbols.push(new ir::Symbol(self.path, def.name, self.get_named_type(def.name)))
            case *:
                pass

    meth func_or_meth_step3(ast::FuncOrMethodDef def, ir::BasicType | null classtype):
        switch def.returntype:
            case ast::Type type:
                let returntype = new (ir::Type | ir::NoReturn | null)(self.get_type(type, null))
            case ast::NoReturn _:
                returntype = new ir::NoReturn()
            case null _:
                returntype = null

        let functype = new ir::FunctionType(
            [foreach arg of def.args: self.get_type(arg.type, null)],
            returntype
        )
        if classtype == null:
            # TODO: does add_var handle this?
            foreach named_var of self.variables:
                assert(def.name != named_var.name)

            # TODO: use def.export
            let func_var = new ir::FileVariable(def.name, functype)
            self.symbols.push(new ir::Symbol(self.path, def.name, func_var))
            self.add_var(func_var, def.name)
        else:
            foreach method of classtype.get().methods:
                assert(method.name != def.name)

            classtype.get().methods.push(new ir::Method(def.name, functype))

    meth do_step3(ast::ToplevelDeclaration top_declaration):
        switch top_declaration:
            case ast::FuncOrMethodDef funcdef:
                self.func_or_meth_step3(funcdef, null)

            case ast::ClassDef classdef:
                let found = false   # TODO: this sucks
                foreach t of self.types:
                    if t.name == classdef.name:
                        let classtype = t.type as ir::BasicType
                        found = true
                        break
                assert(found)

                classtype.members.push_all([
                    foreach member of classdef.members:
                    new ir::Member(member.name, self.get_type(member.type, null))
                ])
                # TODO: is it possible to specify this when creating classtype?
                # TODO: auto types not working at all here
                classtype.constructor_argtypes = new (List[ir::Type] | null)(new List[ir::Type]())
                classtype.constructor_argtypes.get().push_all([
                    foreach member of classtype.members: member.type
                ])

                if classtype.create_to_string_method:
                    # TODO: do this in ir instead?
                    classtype.methods.push(new ir::Method(
                        "to_string",
                        new ir::FunctionType([new ir::Type(classtype)], self.builtins.STR)
                    ))
                if "equals" not in [foreach method of classdef.body: method.name]:
                    classtype.methods.push(new ir::Method(
                        "equals", new ir::FunctionType(
                            [new ir::Type(classtype), new ir::Type(classtype)],
                            self.builtins.BOOL
                        )
                    ))

                foreach method_def of classdef.body:
                    let self_location = classdef.location   # a bit weird
                    method_def.args.insert(0, new ast::TypeAndName(
                        new ast::NamedType(self_location, classtype.name),
                        "self",
                        self_location
                    ))
                    self.func_or_meth_step3(method_def, classtype)

            case *:
                pass

    meth func_or_meth_step4(
        ast::FuncOrMethodDef def, ir::Type | null classtype
    ) -> ir::ToplevelDeclaration:
        if classtype == null:
            let funcvar = self.get_var(def.name, null)
            let functype = ir::var_type(funcvar) as ir::FunctionType  # TODO: error
        else:
            functype = ir::get_method(classtype.get(), def.name, self.builtins)

        let local_vars = self.variables.reversed().reversed()  # TODO: better way to copy list
        let argvars = []
        let body = []

        let local_var_counter = 0
        assert(def.args.length() == functype.argtypes.length())
        for let i = 0; i < def.args.length(); i = i+1:   # TODO: zip
            let argname = def.args.get(i).name
            let arg_location = def.args.get(i).name_location
            let type = functype.argtypes.get(i)

            local_var_counter = local_var_counter + 1
            let argvar = new ir::LocalVariable(type, local_var_counter, arg_location)
            argvars.push(argvar)

            # Copy arguments to separate local variables to allow assigning to arguments
            # TODO: is this necessary?
            let copied_var = new ir::LocalVariable(type, local_var_counter, arg_location)
            local_var_counter = local_var_counter + 1
            body.push(new ir::Instruction(new ir::VarCpy(copied_var, argvar)))
            body.push(new ir::IncRef(copied_var))

            foreach named_var of local_vars:
                assert(named_var.name != argname)
            local_vars.push(new NamedVariable(argname, copied_var))

        # TODO: this sucks
        switch functype.returntype:
            case ir::Type rettype:
                let non_noreturn_returntype = new (null | ir::Type)(rettype)
            case *:
                non_noreturn_returntype = null

        let converter = new FunctionOrMethodConverter(
            self.builtins,
            self,
            local_vars,
            non_noreturn_returntype,
            [], [], [], [], [],
            0, 0,
            local_var_counter,
        )
        foreach statement of def.body:
            converter.do_statement(statement)
        converter.get_rid_of_auto_everywhere()
        body.push_all(converter.code)

        if classtype == null:
            return new ir::FuncDef(funcvar as ir::FileVariable, argvars, body)
        else:
            #assert not def.export
            return new ir::MethodDef(def.name, functype, argvars, body)

    meth do_step4(ast::ToplevelDeclaration top_declaration) -> List[ir::ToplevelDeclaration]:
        switch top_declaration:
            case ast::ClassDef classdef:
                let found = false
                foreach named_type of self.types:
                    if named_type.name == classdef.name:
                        let classtype = named_type.type
                        found = true
                        break
                assert(found)

                let typed_method_defs = []
                if "equals" not in [foreach method of classdef.body: method.name]:
                    typed_method_defs.push(new ir::ToplevelDeclaration(
                        create_pointers_equal_method(self.builtins, classtype, classdef.location)
                    ))

                foreach method_def of classdef.body:
                    typed_method_defs.push(self.func_or_meth_step4(method_def, classtype) as ir::MethodDef)
                return typed_method_defs

            case ast::FuncOrMethodDef funcdef:
                return [self.func_or_meth_step4(funcdef, null)]

            case *:
                return []


export func convert_program(
    ir::Builtins builtins,
    List[ast::ToplevelDeclaration] program,
    Str path,
    List[ir::Symbol] symbols,
) -> List[ir::ToplevelDeclaration]:

    let converter = new FileConverter(
        builtins,
        path,
        symbols,
        [foreach type of builtins.get_builtin_types(): new NamedType(ir::type_name(type), type)],
        [new NamedGeneric("List", builtins.LIST)],
        [foreach var of builtins.visible_vars: new NamedVariable(var.name, var)],
        [],
    )


    foreach top of program:
        converter.do_step1(top)
    foreach top of program:
        converter.do_step2(top)
    assert(converter.typedef_laziness == [])
    foreach top of program:
        converter.do_step3(top)

    let result = []
    foreach top of program:
        result.push_all(converter.do_step4(top))
    return result
