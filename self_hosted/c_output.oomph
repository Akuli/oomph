import "<stdlib>/hash.oomph" as hash
import "<stdlib>/io.oomph" as io
import "ir.oomph" as ir

# The resulting C code is unreadable anyway, but please follow these conventions:
#   - When you use ";", add a trailing newline by using a multiline string or
#     with ";\n". This avoids making lines really long, so even though the code
#     is unreadable, C compiler error messages are not.
#   - Don't care about indentation.

func emit_label(Str name) -> Str:
    # It's invalid c syntax to end a block with a label, (void)0 fixes
    return "{name}: (void)0;\n"

func create_id(Str readable_part, Str identifying_part) -> Str:
    let result = ""
    foreach char of readable_part.split(""):
        # TODO: avoid starting with digit?
        if char in "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789":
            result = result + char
        else:
            result = result + "_"

    return result + "_" + hash::md5(identifying_part).split("").slice(0, 10).join("")

func is_pointer(ir::Type type, ir::Builtins builtins) -> Bool:
    switch type:
        case ir::UnionType _:
            return false
        case ir::BasicType basic:
            return ir::is_refcounted(type) and type != builtins.STR and (
                basic.generic_source == null
                or (basic.generic_source as not null).generik != builtins.MAPPING_ITEM
            )
        case *:
            return ir::is_refcounted(type)


func create_function_emitter(FilePair file_pair) -> FunctionEmitter:
    return new FunctionEmitter(
        file_pair,
        # https://github.com/Akuli/oomph/issues/216
        new Mapping[ir::LocalVariable, auto](),
        new Mapping[ir::GotoLabel, auto](),
        "", "", [],
    )

class FunctionEmitter(
    FilePair file_pair,
    Mapping[ir::LocalVariable, Str] local_vars,
    Mapping[ir::GotoLabel, Str] labels,
    Str before_body,
    Str after_body,
    List[ir::LocalVariable] need_decref,  # TODO: do this in c_output?
):

    meth incref_var(ir::LocalVariable var) -> Str:
        return self.file_pair.session.emit_incref(self.emit_var(var), var.type)

    meth emit_call(
        Str function,
        List[ir::LocalVariable] args,
        ir::LocalVariable | null result_var,
    ) -> Str:
        let args_string = [foreach arg of args: self.emit_var(arg)].join(",")
        switch result_var:
            case ir::LocalVariable var:
                return "{self.emit_var(var)} = {function}({args_string});\n"
            case null _:
                return "{function}({args_string});\n"

    meth emit_body(List[ir::Instruction] body) -> Str:
        return [foreach ins of body: self.emit_instruction(ins)].join("")

    meth emit_instruction(ir::Instruction instruction) -> Str:
        switch instruction:
            case ir::StringConstant cons:
                return """
                {self.emit_var(cons.var)} = {self.file_pair.emit_string(cons.value)};
                {self.incref_var(cons.var)};
                """

            case ir::IntConstant cons:
                return "{self.emit_var(cons.var)} = {cons.value}LL;\n"

            case ir::FloatConstant cons:
                return "{self.emit_var(cons.var)} = {cons.value};\n"

            case ir::VarCpy copy:
                return "{self.emit_var(copy.dest)} = {self.emit_var(copy.source)};\n"

            case ir::IncRef inc:
                return self.incref_var(inc.var) + ";\n"

            case ir::DecRef dec:
                return self.file_pair.session.emit_decref(self.emit_var(dec.var), dec.var.type) + ";\n"

            case ir::FunctionCall call:
                return self.emit_call(self.emit_var(call.function), call.args, call.result)

            case ir::MethodCall call:
                # TODO: list + list
                let args = [call.obj]
                args.push_all(call.args)
                let name = "meth_{self.file_pair.session.get_type_c_name(call.obj.type)}_{call.method_name}"
                return self.emit_call(name, args, call.result)

            case ir::ConstructorCall call:
                let name = "ctor_" + self.file_pair.session.get_type_c_name(call.result.type)
                return self.emit_call(name, call.args, call.result)

            case ir::Return ret:
                switch ret.value:
                    case ir::LocalVariable retval:
                        return """
                        {self.incref_var(retval)};
                        retval = {self.emit_var(retval)};
                        goto out;
                        """
                    case null _:
                        return "goto out;\n"

            # TODO: union attribs https://github.com/Akuli/oomph/issues/145
            case ir::GetAttribute getattr:
                if is_pointer(getattr.obj.type, self.file_pair.session.builtins):
                    let op = "->"
                else:
                    op = "."
                let var = self.emit_var(getattr.attribute_var)
                let attrib = self.emit_var(getattr.obj) + op + "memb_" + getattr.attribute
                return "{var} = {attrib};\n"
            case ir::SetAttribute getattr:
                if is_pointer(getattr.obj.type, self.file_pair.session.builtins):
                    let op = "->"
                else:
                    op = "."
                let var = self.emit_var(getattr.attribute_var)
                let attrib = self.emit_var(getattr.obj) + op + "memb_" + getattr.attribute
                return "{attrib} = {var};\n"

            case ir::InstantiateUnion inst:
                let union = inst.result.type as ir::UnionType
                let membernum = union.type_members.find_only(inst.value.type)
                return """
                {self.emit_var(inst.result)} = ({self.file_pair.emit_type(union)}) \{
                    .val = \{ .item{membernum} = {self.emit_var(inst.value)} \},
                    .membernum = {membernum},
                \};
                """

            case ir::GetFromUnion get:
                let union = get.union_var.type as ir::UnionType
                let membernum = union.type_members.find_only(get.result.type)
                return """
                assert({self.emit_var(get.union_var)}.membernum == {membernum});
                {self.emit_var(get.result)} = {self.emit_var(get.union_var)}.val.item{membernum};
                """

            case ir::UnSet unset:
                # TODO: this isn't pretty
                switch unset.var.type:
                    case ir::UnionType _:
                        return "{self.emit_var(unset.var)}.membernum = -1;\n"
                    case ir::BasicType basic:
                        if (
                            basic.generic_source != null
                            and (
                                (basic.generic_source as not null).generik ==
                                self.file_pair.session.builtins.MAPPING_ITEM
                            )
                        ):
                            return "{self.emit_var(unset.var)}.hash = 0;\n"
                        if basic == self.file_pair.session.builtins.STR:
                            return self.emit_var(unset.var) + ".buf = NULL;\n"
                    case *:
                        pass

                if ir::is_refcounted(unset.var.type):
                    # Pointer type
                    return self.emit_var(unset.var) + " = NULL;\n"
                return ""

            case ir::Panic panic:
                # TODO: include file name and line number
                return """
                panic_printf("%s", string_to_cstr({self.file_pair.emit_string(panic.message)}));
                """

            case ir::GotoLabel label:
                return emit_label(self.get_label_name(label))

            case ir::GotoIf goto:
                return """
                if ({self.emit_var(goto.cond)})
                    goto {self.get_label_name(goto.label)};
                """

            case ir::UnionMemberCheck check:
                let membernum = (check.union_var.type as ir::UnionType).type_members.find_only(check.member_type)
                return "{self.emit_var(check.result)} = ({self.emit_var(check.union_var)}.membernum == {membernum});\n"

    meth get_label_name(ir::GotoLabel label) -> Str:
        if not self.labels.has_key(label):
            self.labels.set(label, "label" + self.labels.length().to_string())
        return self.labels.get(label)

    meth add_local_var(ir::LocalVariable var, Bool declare_and_decref):
        let name = "var" + self.local_vars.length().to_string()
        assert(not self.local_vars.has_key(var))
        self.local_vars.set(var, name)

        if declare_and_decref:
            # TODO: add UnSets in ast2ir?
            self.before_body = self.before_body + """
            {self.file_pair.emit_type(var.type)} {name};
            """ + self.emit_instruction(new ir::UnSet(var))

            assert(var not in self.need_decref)
            self.need_decref.push(var)

    meth emit_var(ir::Variable var) -> Str:
        switch var:
            case ir::LocalVariable local_var:
                if not self.local_vars.has_key(local_var):
                    self.add_local_var(local_var, true)
                return self.local_vars.get(local_var)
            case *:
                return self.file_pair.emit_var(var)

    meth emit_funcdef(ir::FuncDef | ir::MethodDef funcdef, Str c_name):
        switch funcdef:
            case ir::FuncDef fdef:
                let argvars = fdef.argvars
                let functype = fdef.var.type as ir::FunctionType
                let body = fdef.body
            case ir::MethodDef mdef:
                argvars = mdef.argvars
                functype = mdef.type
                body = mdef.body

        foreach var of argvars:
            self.add_local_var(var, false)

        let body_instructions = self.emit_body(body)
        # TODO: is reversing still needed?
        let decrefs = [
            foreach var of self.need_decref.reversed(): 
            self.file_pair.session.emit_decref(self.emit_var(var), var.type) + ";\n"
        ].join("")

        switch functype.returntype:
            case ir::Type type:
                self.before_body = self.before_body + """
                {self.file_pair.emit_type(type)} retval;
                """
                self.after_body = self.after_body + "return retval;\n"
            case *:
                pass

        # TODO: couldn't get list comprehension to work
        let foo = new List[Str]()
        foreach var of argvars:
            foo.push(self.emit_var(var))

        self.file_pair.define_function(
            c_name,
            functype,
            foo,
            (
                self.before_body
                + body_instructions
                + emit_label("out")
                + decrefs
                + self.after_body
            ),
        )


func trim_leading_underscores(Str s) -> Str:
    while s.starts_with("_"):
        s = s.remove_prefix("_")
    return s


# TODO: these suck
func method_keys(Mapping[Str, ir::FunctionType] map) -> List[Str]:
    return map.keys()
func member_keys(Mapping[Str, ir::Type] map) -> List[Str]:
    return map.keys()


# Represents .c and .h file, and possibly *the* type defined in those.
# That's right, each type goes to separate .c and .h file.
class FilePair(
    Session session,
    Str id,  # used in file names and type names
    ir::Type | Str type_or_source_path,
    List[Str] strings,
    Str | null struct,
    Str string_defs,
    Str function_decls,
    Str function_defs,
    # When a FilePair is in h_includes, the corresponding h_fwd_decls are unnecessary
    List[FilePair] c_includes,
    List[FilePair] h_includes,
    Str h_fwd_decls,
):
    # Usually can_fwd_declare_in_header should be true
    # TODO: default values of arguments
    meth emit_type(ir::Type type) -> Str:
        return self.emit_type_custom(type, true)

    meth emit_type_custom(ir::Type type, Bool can_fwd_declare_in_header) -> Str:
        switch type:
            case ir::AutoType _:
                assert(false)
            case *:
                pass

        if type == self.session.builtins.INT:
            return "int64_t"
        if type == self.session.builtins.FLOAT:
            return "double"
        if type == self.session.builtins.BOOL:
            return "bool"
        if type == self.session.builtins.STR:
            return "struct class_Str"  # TODO: rename the struct?
        if type == self.session.builtins.NULL_TYPE:
            return "char"  # always zero
        assert(type not in self.session.builtins.get_builtin_types())

        let defining_file_pair = self.session.type_to_file_pair(type)
        let result = "struct class_{defining_file_pair.id}"

        if is_pointer(type, self.session.builtins):
            result = result + "*"
        else:
            can_fwd_declare_in_header = false

        if defining_file_pair != self:
            if defining_file_pair not in self.c_includes:
                self.c_includes.push(defining_file_pair)

            if can_fwd_declare_in_header:
                self.h_fwd_decls = self.h_fwd_decls + "struct class_{defining_file_pair.id};\n"
            else:
                if defining_file_pair not in self.h_includes:
                    self.h_includes.push(defining_file_pair)

        return result

    meth emit_var(ir::Variable var) -> Str:
        switch var:
            case ir::LocalVariable _:
                assert(false)
            case ir::BuiltinVariable builtin:
                return "oomph_" + trim_leading_underscores(builtin.name)
            case ir::FileVariable filevar:
                foreach symbol of self.session.symbols:
                    if symbol.value == filevar:
                        let pair = self.session.source_path_to_file_pair(symbol.path)
                        if pair != self:
                            if pair not in self.c_includes:
                                self.c_includes.push(pair)
                            if pair not in self.h_includes:
                                self.h_includes.push(pair)
                            return pair.emit_var(filevar)

                if filevar.name == "main":
                    return "oomph_main"
                if filevar.name in [
                    "__Bool_to_string",
                    "__List_Str_join",
                    "__Str___contains",
                    "__Str_center_pad",
                    "__Str_count",
                    "__Str_from_start_to_substring",
                    "__Str_get_utf8",
                    "__Str_left_pad",
                    "__Str_left_trim",
                    "__Str_remove_prefix",
                    "__Str_remove_suffix",
                    "__Str_repeat",
                    "__Str_replace",
                    "__Str_right_pad",
                    "__Str_right_trim",
                    "__Str_split",
                    "__Str_trim",
                ]:
                    # Class implemented in C, method in builtins.oomph
                    # TODO: check if this file is builtins.oomph
                    return "meth_" + trim_leading_underscores(filevar.name)
                return self.id + "_" + filevar.name

    # If body is None, declares but does not actually define
    meth define_function(
        Str function_name,
        ir::FunctionType type,
        List[Str] | null argnames,
        Str | null body,
    ):
        switch argnames:
            case null _:
                let arg_decls = [foreach t of type.argtypes: self.emit_type(t)]
            case List[Str] names:
                # TODO: zip
                assert(names.length() == type.argtypes.length())
                arg_decls = [
                    for let i = 0; i < names.length(); i = i+1:
                    self.emit_type(type.argtypes.get(i)) + " " + names.get(i)
                ]

        let arg_decl_string = arg_decls.join(",")
        if arg_decl_string == "":
            arg_decl_string = "void"

        switch type.returntype:
            case ir::NoReturn _:
                let returntype = "noreturn void"
            case null _:
                returntype = "void"
            case ir::Type an_actual_type:
                returntype = self.emit_type(an_actual_type)

        let decl = "{returntype} {function_name}({arg_decl_string})"
        self.function_decls = self.function_decls + decl + ";\n"
        if body != null:
            self.function_defs = self.function_defs + decl + "\{" + (body as not null) + "\}\n"

    meth emit_string(Str value) -> Str:
        let first_time_with_this_value = value not in self.strings
        if first_time_with_this_value:
            self.strings.push(value)

        # Including the full value in first argument of create_id causes issue #132
        # I like to include some parts of string content for debugging though
        let shortened = value.split("").slice(0, 20).join("")
        let varname = create_id("string" + self.strings.find_only(value).to_string() + shortened, value)

        if first_time_with_this_value:
            let content_chars = [foreach c of value.get_utf8(): "(char){c}"]
            if content_chars == []:
                content_chars.push("0")  # empty c arrays aren't a thing

            self.string_defs = self.string_defs + """
            static struct StringBuf {varname}_buf = \{
                .refcount = -1,
                .data = (char[])\{ {content_chars.join(",")} \},
                .malloced = false,
                .len = {value.get_utf8().length()},
            \};
            static struct class_Str {varname} = \{
                .buf = &{varname}_buf,
                .nbytes = {value.get_utf8().length()},
                .offset = 0,
            \};
            """

        return varname

    meth define_union(ir::UnionType union):
        # TODO: enumerate
        let n = union.type_members.length()

        let member_cnames = [foreach member of union.type_members: self.session.get_type_c_name(member)]
        let to_string_cases = [
            for let i = 0; i < n; i = i+1:
                """
                case {i}:
                    valstr = meth_{member_cnames.get(i)}_to_string(obj.val.item{i});
                    break;
                """
        ].join("")
        let equals_cases = [
            for let i = 0; i < n; i = i+1:
                """
                case {i}:
                    return meth_{member_cnames.get(i)}_equals(a.val.item{i}, b.val.item{i});
                """
        ].join("")
        let hash_cases = [
            for let i = 0; i < n; i = i+1:
                """
                case {i}:
                    return meth_{member_cnames.get(i)}_hash(obj.val.item{i});
                """
        ].join("")

        # TODO: can decls be emitted automatically?
        self.function_decls = self.function_decls + """
        struct class_Str meth_{self.id}_to_string(struct class_{self.id} obj);
        bool meth_{self.id}_equals(struct class_{self.id} a, struct class_{self.id} b);
        """

        let type_name_code = self.emit_string(ir::type_name(union))
        self.function_defs = self.function_defs + """
        struct class_Str meth_{self.id}_to_string(struct class_{self.id} obj)
        \{
            struct class_Str valstr;
            switch(obj.membernum) \{
                {to_string_cases}
                default:
                    panic_printf(
                        "INTERNAL OOMPH ERROR: invalid %s membernum %d",
                        string_to_cstr({type_name_code}), (int)obj.membernum);
            \}

            struct class_Str res = {self.emit_string(ir::type_name(union))};
            incref_Str(res);
            oomph_string_concat_inplace_cstr(&res, "(");
            oomph_string_concat_inplace(&res, valstr);
            oomph_string_concat_inplace_cstr(&res, ")");
            decref_Str(valstr);
            return res;
        \}

        bool meth_{self.id}_equals(struct class_{self.id} a, struct class_{self.id} b)
        \{
            if (a.membernum != b.membernum)
                return false;
            switch(a.membernum) \{
                {equals_cases}
                default:
                    panic_printf(
                        "INTERNAL OOMPH ERROR: invalid %s membernum %d",
                        string_to_cstr({type_name_code}), (int)a.membernum);
            \}
        \}
        """

        # To incref/decref unions, we need to know the value of membernum
        # and incref/decref the correct member of the union. Union-specific
        # functions handle that.
        let increfs = [for let i = 0; i < n; i = i+1: self.session.emit_incref("obj.val.item{i}", union.type_members.get(i))]
        let decrefs = [for let i = 0; i < n; i = i+1: self.session.emit_decref("obj.val.item{i}", union.type_members.get(i))]
        let incref_cases = [for let i = 0; i < n; i = i+1: "case {i}: {increfs.get(i)}; break;\n"].join("")
        let decref_cases = [for let i = 0; i < n; i = i+1: "case {i}: {decrefs.get(i)}; break;\n"].join("")

        self.function_decls = self.function_decls + """
        void incref_{self.id}(struct class_{self.id} obj);
        void decref_{self.id}(struct class_{self.id} obj);
        """
        self.function_defs = self.function_defs + """
        void incref_{self.id}(struct class_{self.id} obj) \{
            switch(obj.membernum) \{
                {incref_cases}
                default:
                    assert(0);
            \}
        \}
        void decref_{self.id}(struct class_{self.id} obj) \{
            switch(obj.membernum) \{
                case -1:   // variable not in use (see UnSet)
                    break;
                {decref_cases}
                default:
                    assert(0);
            \}
        \}
        """

        if ir::get_methods(union, self.session.builtins).has_key("hash"):
            self.function_decls = self.function_decls + """
            int64_t meth_{self.id}_hash(struct class_{self.id} obj);
            """
            self.function_defs = self.function_defs + """
            int64_t meth_{self.id}_hash(struct class_{self.id} obj) \{
                switch(obj.membernum) \{
                    {hash_cases}
                    default:
                        panic_printf("internal error in union hash");
                \}
            \}
            """

        let union_members = [for let i = 0; i < n; i = i+1: "{self.emit_type(union.type_members.get(i))} item{i};\n"].join("")
        assert(self.struct == null)
        self.struct = """
        struct class_{self.id} \{
            union \{
                {union_members}
            \} val;
            short membernum;
        \};
        """ as Str | null

    meth define_generic_type(ir::BasicType type):
        let source = type.generic_source as not null
        let macrotypes = new Mapping[Str, ir::Type]()

        if source.generik == self.session.builtins.LIST:
            assert(source.args.length() == 1)
            let c_path = "lib/generic/list.c"
            let h_path = "lib/generic/list.h"
            macrotypes.set("LIST", type)
            macrotypes.set("ITEM", source.args.first())
        elif source.generik == self.session.builtins.MAPPING:
            assert(source.args.length() == 2)
            c_path = "lib/generic/mapping.c"
            h_path = "lib/generic/mapping.h"
            let keytype = source.args.first()
            let valtype = source.args.last()
            let itemtype = self.session.builtins.generic2type(self.session.builtins.MAPPING_ITEM, source.args, null)
            macrotypes.set("MAPPING", type)
            macrotypes.set("KEY", keytype)
            macrotypes.set("VALUE", valtype)
            macrotypes.set("ITEM", itemtype)
            macrotypes.set("KEY_LIST", self.session.builtins.generic2type(self.session.builtins.LIST, [keytype], null))
            macrotypes.set("VALUE_LIST", self.session.builtins.generic2type(self.session.builtins.LIST, [valtype], null))
            macrotypes.set("ITEM_LIST", self.session.builtins.generic2type(self.session.builtins.LIST, [itemtype], null))
        elif source.generik == self.session.builtins.MAPPING_ITEM:
            assert(source.args.length() == 2)
            c_path = "lib/generic/mapping_item.c"
            h_path = "lib/generic/mapping_item.h"
            macrotypes.set("KEY", source.args.first())
            macrotypes.set("VALUE", source.args.last())
            macrotypes.set("ITEM", type)
        else:
            assert(false)

        let macros = new Mapping[Str, Str]()
        foreach item of macrotypes.items():
            let cname = self.session.get_type_c_name(item.value)
            macros.set(item.key, self.emit_type_custom(item.value, false))
            macros.set("{item.key}_STRUCT", "class_{cname}")
            macros.set("{item.key}_CTOR", "ctor_{cname}")
            macros.set("{item.key}_DTOR", "dtor_{cname}")
            macros.set("{item.key}_METHOD(name)", "meth_{cname}_##name")
            macros.set("{item.key}_INCREF(val)", self.session.emit_incref("val", item.value))
            macros.set("{item.key}_DECREF(val)", self.session.emit_decref("val", item.value))
            if item.value == self.session.builtins.STR:
                macros.set("{item.key}_IS_STRING", "1")
            else:
                macros.set("{item.key}_IS_STRING", "0")

        let defines = "\n"
        let undefs = "\n"
        foreach item of macros.items():
            defines = defines + "#define {item.key} {item.value}\n"
            let name = item.key.split("(").first()
            undefs = undefs + "#undef {name}\n"

        assert(self.struct == null)
        self.struct = (defines + io::read_file(h_path) + undefs) as Str | null

        let method_mapping = ir::get_methods(type, self.session.builtins)
        foreach methodname of method_keys(method_mapping):
            self.define_function(
                "meth_{self.session.get_type_c_name(type)}_{methodname}",
                method_mapping.get(methodname),
                null, null,
            )

        self.function_defs = self.function_defs + defines + io::read_file(c_path) + undefs

    meth define_simple_type(ir::BasicType type):
        let struct_members = [foreach m of member_keys(type.members): "{self.emit_type(type.members.get(m))} memb_{m};\n"].join("")
        let constructor_args = [foreach m of member_keys(type.members): "{self.emit_type(type.members.get(m))} arg_{m}"].join(",")
        if constructor_args == "":
            constructor_args = "void"
        let member_assignments = [foreach m of member_keys(type.members): "obj->memb_{m} = arg_{m};\n"].join("")
        let member_increfs = [foreach m of member_keys(type.members): self.session.emit_incref("obj->memb_{m}", type.members.get(m)) + ";\n"].join("")
        let member_decrefs = [foreach m of member_keys(type.members): self.session.emit_decref("obj->memb_{m}", type.members.get(m)) + ";\n"].join("")

        assert(self.struct == null)
        self.struct = """
        struct class_{self.id} \{
            REFCOUNT_HEADER
            {struct_members}
        \};
        """ as Str | null
        self.function_decls = self.function_decls + """
        {self.emit_type(type)} ctor_{self.id}({constructor_args});
        void dtor_{self.id}(void *ptr);
        """
        self.function_defs = self.function_defs + """
        {self.emit_type(type)} ctor_{self.id}({constructor_args})
        \{
            {self.emit_type(type)} obj = malloc(sizeof(*obj));
            assert(obj);
            obj->refcount = 1;
            {member_assignments}
            {member_increfs}
            return obj;
        \}

        void dtor_{self.id}(void *ptr)
        \{
            struct class_{self.id} *obj = ptr;
            {member_decrefs}
            free(obj);
        \}
        """

        foreach name of type.methods_to_create:
            if name == "to_string":
                self.function_decls = self.function_decls + """
                struct class_Str meth_{self.id}_to_string({self.emit_type(type)} obj);
                """
                let concats = [
                    foreach m of member_keys(type.members):
                        """
                        tmp = meth_{self.session.get_type_c_name(type.members.get(m))}_to_string(self->memb_{m});
                        oomph_string_concat_inplace(&res, tmp);
                        decref_Str(tmp);
                        """
                ].join("oomph_string_concat_inplace_cstr(&res, \", \");")
                self.function_defs = self.function_defs + """
                struct class_Str meth_{self.id}_to_string({self.emit_type(type)} self)
                \{
                    struct class_Str res = {self.emit_string(type.name)};
                    struct class_Str tmp;
                    oomph_string_concat_inplace_cstr(&res, "(");
                    {concats}
                    oomph_string_concat_inplace_cstr(&res, ")");
                    return res;
                \}
                """
            elif name == "equals":
                self.function_decls = self.function_decls + """
                // pointer equality
                #define meth_{self.id}_equals(a, b) ((a) == (b))
                """
            elif name == "hash":
                self.function_decls = self.function_decls + "\n#define meth_{self.id}_hash pointer_hash\n"
            else:
                assert(false)

    # Must not be called multiple times for the same FilePair
    meth define_type(ir::Type type):
        switch type:
            case ir::AutoType | ir::FunctionType _:
                assert(false)
            case ir::UnionType union:
                self.define_union(union)
            case ir::BasicType basictype:
                if basictype.generic_source == null:
                    self.define_simple_type(basictype)
                else:
                    self.define_generic_type(basictype)

    meth emit_toplevel_declaration(ir::ToplevelDeclaration top_declaration):
        switch top_declaration:
            case ir::FuncDef funcdef:
                create_function_emitter(self).emit_funcdef(funcdef, self.emit_var(funcdef.var))
            case ir::MethodDef methdef:
                let klass = methdef.type.argtypes.first()
                let file_pair = self.session.type_to_file_pair(klass)
                let name = "meth_{self.session.get_type_c_name(klass)}_{methdef.name}"
                create_function_emitter(file_pair).emit_funcdef(methdef, name)


# This state is shared between different files
export class Session(
    ir::Builtins builtins,
    Str compilation_dir,
    List[ir::Symbol] symbols,
    List[FilePair] file_pairs,
):
    # Gets rid of reference cycles
    meth destroy():
        while self.file_pairs != []:
            self.file_pairs.pop()

    meth source_path_to_file_pair(Str path) -> FilePair:
        foreach pair of self.file_pairs:
            if pair.type_or_source_path == path:
                return pair
        assert(false)

    meth type_to_file_pair(ir::Type type) -> FilePair:
        foreach pair of self.file_pairs:
            if pair.type_or_source_path == type:
                return pair

        let pair = new FilePair(
            self,
            create_id(ir::type_name(type), ir::type_id_string(type)),
            type,
            [], null, "", "", "", [], [], "",
        )
        self.file_pairs.push(pair)
        pair.define_type(type)
        return pair

    meth get_type_c_name(ir::Type type) -> Str:
        if type in self.builtins.get_builtin_types():
            return ir::type_name(type)
        return self.type_to_file_pair(type).id

    # May evaluate c_expression several times
    meth emit_incref(Str c_expression, ir::Type type) -> Str:
        if is_pointer(type, self.builtins):
            return "incref({c_expression})"
        if ir::is_refcounted(type):
            return "incref_{self.get_type_c_name(type)}({c_expression})"
        return "(void)0"

    meth emit_decref(Str c_expression, ir::Type type) -> Str:
        if is_pointer(type, self.builtins):
            return "decref(({c_expression}), dtor_{self.get_type_c_name(type)})"
        if ir::is_refcounted(type):
            return "decref_{self.get_type_c_name(type)}({c_expression})"
        return "(void)0"

    meth create_c_code(List[ir::ToplevelDeclaration] top_decls, Str source_path):
        foreach pair of self.file_pairs:
            assert(pair.type_or_source_path != source_path)

        let pair = new FilePair(
            self,
            create_id(
                source_path.split("/").last().split(".").first(),
                # TODO: use relative path
                #os.path.relpath(source_path, self.compilation_dir.parent),
                source_path,
            ),
            source_path,
            [], null, "", "", "", [], [], "",
        )
        self.file_pairs.push(pair)
        foreach top_declaration of top_decls:
            pair.emit_toplevel_declaration(top_declaration)

    # returns list of c paths
    # TODO: don't keep stuff in memory so much
    meth write_everything(Str builtins_path) -> List[Str]:
        let builtins_pair = self.source_path_to_file_pair(builtins_path)

        let c_paths = []
        foreach file_pair of self.file_pairs:
            let c_path = self.compilation_dir + "/" + file_pair.id + ".c"
            let h_path = self.compilation_dir + "/" + file_pair.id + ".h"
            c_paths.push(c_path)

            let c_includes = [file_pair.id + ".h"]
            let h_includes = []

            if file_pair != builtins_pair:
                c_includes.push(builtins_pair.id + ".h")
                h_includes.push(builtins_pair.id + ".h")

            c_includes.push_all([foreach pair of file_pair.c_includes: pair.id + ".h"])
            h_includes.push_all([foreach pair of file_pair.h_includes: pair.id + ".h"])

            # TODO: https://github.com/Akuli/oomph/issues/80
            if file_pair.struct == null:
                let struct = ""
            else:
                struct = file_pair.struct as not null

            let h_code = (
                "#include <lib/oomph.h>\n"
                + [foreach include of h_includes: "#include \"{include}\"\n"].join("")
                + file_pair.h_fwd_decls
                + struct
                + file_pair.function_decls
            )
            let c_code = (
                "#include <lib/oomph.h>\n"
                + [foreach include of c_includes: "#include \"{include}\"\n"].join("")
                + file_pair.string_defs
                + file_pair.function_defs
            )

            let header_guard = "HEADER_GUARD_" + file_pair.id
            io::write_file(c_path, c_code)
            io::write_file(h_path, """
            #ifndef {header_guard}
            #define {header_guard}
            {h_code}
            #endif
            """)

        return c_paths
