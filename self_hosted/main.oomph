import "<stdlib>/io.oomph" as io
import "<stdlib>/process.oomph" as process
import "ast.oomph" as ast
import "ast2ir.oomph" as ast2ir
import "ast_transformer.oomph" as ast_transformer
import "c_output.oomph" as c_output
import "ir.oomph" as ir
import "parser.oomph" as parser
import "util.oomph" as util


class CompilationUnit(
    Str source_path,
    c_output::Session session,
    List[ast::ToplevelDeclaration] ast,
):
    meth create_ast():
        let source_code = self.source_path.read_text(encoding="utf-8")
        self.ast = ast_transformer::transform(parser::parse_file(
            source_code, self.source_path, project_root / "stdlib"
        ))

    # Returns source paths
    meth get_dependencies() -> List[Str]:
        let result = []
        if self.source_path == "builtins.oomph":
            result.push("builtins.oomph")
        foreach top_decl of self.ast:
            switch top_decl:
                case ast::Import imp:
                    result.push(imp.path)
                case *:
                    pass
        return result

    meth create_c_code(List[ir::Symbol] exports):
        let ir = ast2ir::convert_program(self.ast, self.source_path, exports)
        self.session.create_c_code(ir, self.source_path)


# split() and join() don't cover all corner cases
func split(Str s) -> List[Str]:
    # TODO: use quoting rules
    let result = s.split(" ")
    while "" in result:
        result.delete_first("")
    return result

func join(List[Str] args) -> Str:
    let result = []
    foreach arg of args:
        if " " in arg:
            result.push("'" + arg + "'")
        else:
            result.push(arg)
    return result.join(" ")


class Command(List[Str] command, Str human_readable)

func get_c_compiler_command(List[Str] C_paths, Str exepath) -> Command:
    let cc = new (Str | null)(null)
    let cflags = (new Str | null)(null)
    let ldflags = (new Str | null)(null)

    foreach line of io::read_file("obj/compile_info.txt").split("\n"):
        if line.starts_with("cc="):
            cc = line.remove_prefix("cc=")
        elif line.starts_with("cflags="):
            cflags = line.remove_prefix("cflags=")
        elif line.starts_with("ldflags="):
            ldflags = line.remove_prefix("ldflags=")
        else:
            assert(false)

    let before_files = [cc.get()]
    before_files.push_all(split(cflags))
    before_files.push_all([
        # FIXME: hard-coded list of globbing obj/*.o
        "obj/io.o",
        "obj/string.o",
        "obj/misc.o",
        "obj/ref.o",
        "obj/hash.o",
        "obj/numbers.o",
        "obj/process.o",
    ])

    let after_files = ["-o", exepath]
    after_files.push_all(split(ldflags))
    after_files.push_all(["-I", project_root])

    let all_args = []
    all_args.push_all(before_files)
    all_args.push_all(c_paths)
    all_args.push_all(after_files)

    return new Command(
        all_args,
        join(before_files) + " <{c_paths.length()} files> " + join(after_files),
    )

func run(Command command, Bool verbose) -> int:
    if verbose:
        print("Running: " + command.human_readable)
    return process::run(command.command)


func mkdir_with_parents(Str path):
    let parents = [path]
    while util::path_parent(parents.last()) != parents.last():
        parents.push(util::path_parent(parents.last()))

    foreach parent of parents.reversed():
        io::mkdir(parent)

func get_compilation_dir(Str parent_dir, Str name_hint) -> Str:
    for let i = 0; ; i = i+1:
        let path = "{parent_dir}/{name_hint}{i}"
        mkdir_with_parents(path)

        # TODO: better way to create file if not exists and know whether that was done
        if process::run(["bash", "-c", "printf '' > '{path}/compiling'"]) == 0:
            io::delete_file_at_exit(path + "/compiling")
            return path


func create_compilation_units(c_output::Session session, Str infile, Bool verbose) -> List[CompilationUnit]:
    let units = []
    let queue = [infile]
    while queue != []:
        let source_path = queue.pop()
        if source_path in [foreach unit of units: unit.source_path]:
            continue
        let candidate_unit = new CompilationUnit(source_path, [], session, [])

        if verbose:
            print("Parsing {source_path}")
        candidate_unit.create_ast()
        queue.push_all(candidate_unit.get_dependencies())

    return units

func in_first_but_not_in_second(List[CompilationUnit] a, List[CompilationUnit] b) -> CompilationUnit:
    let result = []
    foreach item of a:
        if item not in b:
            return item
    assert(false)

func compute_compilation_order(List[CompilationUnit] units, Bool verbose) -> List[CompilationUnit]:
    let compilation_order = []
    while compilation_order.length() < units.length():
        let candidate_unit = in_first_but_not_in_second(units, compilation_order)
        let breadcrumbs = [candidate_unit]
        while true:
            let found = false   # TODO: this sucks
            foreach unit of units:
                if unit not in compilation_order and u.source_path in candidate_unit.get_dependencies():
                    let dependency = unit
                    let found = true
            if not found:
                break
            if verbose:
                print("Noticed dependency: {candidate_unit.source_path} --> {dependency.source_path}")

            let cyclic = dependency in breadcrumbs
            breadcrumbs.push(dependency)
            if cyclic:
                # TODO: error
                print("cyclic imports: " + [foreach unit of breadcrumbs: unit.source_path].join(" --> "))
                assert(false)
        compilation_order.push(candidate_unit)

    return compilation_order


class Args(Str infile, Str | null outfile, Str valgrind, Bool verbose, List[Str] program_args)

func parse_args() -> Args:
    let infile = new (Str | null)(null)
    let outfile = new (Str | null)(null)
    let valgrind = ""
    let verbose = false

    # TODO: improve error handling
    let args = process::get_args().reversed()
    while args != []:
        if args.last() == "--help":
            # FIXME: __argv_get shouldn't be used directly
            print("""Usage: {__argv_get(0)} [compiler args] PROGRAM.oomph [program args]

Compiler arguments:
    -o, --outfile FILE
        Put executable here, don't run it

    --valgrind COMMAND  (don't use with --outfile)
        Run program with valgrind, e.g. '--valgrind valgrind' runs with no
        valgrind arguments

    -v, --verbose
        Print lost of stuff
""")
            assert(false)
        if args.last() in ["-o", "--outfile"]:
            args.pop()
            outfile = args.pop()
        elif args.last() == "--valgrind":
            args.pop()
            valgrind = args.last()
        elif args.last() in ["-v", "--verbose"]:
            args.pop()
            verbose = true
        elif args.last().starts_with("-"):
            print("unknown argument: {args.last}")
            assert(false)
        else:
            infile = args.last()
            break

    return new Args(infile.get(), outfile, valgrind, verbose, args.reversed())


export func main():
    let args = parse_args()

    # TODO: put cache dir to current working directory if file in non-writable location
    let cache_dir = util::path_parent(args.infile) + "/.oomph-cache"
    io::mkdir(cache_dir)

    let session = new c_output::Session(
        ir::create_builtins(),
        get_compilation_dir(cache_dir, compiler_args.infile.stem + "_compilation"),
        [],
        [],
    )

    let units = create_compilation_units(session, args.infile, args.verbose)
    foreach unit of compute_compilation_order(units, args.verbose):
        if args.verbose:
            print("Creating C code:", unit.source_path)
        unit.create_c_code(session.symbols)

    # Write out everything and compile it
    let c_paths = session.write_everything("builtins.oomph")
    let exe_path = session.compilation_dir + "/" + compiler_args.infile.split("/").last().split(".").first()
    let command = get_c_compiler_command(c_paths, exe_path)
    let result = run(command, compiler_args.verbose)
    assert(result == 0)

    # If we have an outfile path, move the resulting executable to it and bail
    switch compiler_args.outfile:
        case Str outfile:
            # TODO: more path operations
            assert(process::run(["[", "-d", outfile "]"]) == 1)  # mv is weird for dirs
            if compiler_args.verbose:
                assert(process::run(["mv", "--verbose", exe_path, outfile]) == 0)
            else:
                assert(process::run(["mv", exe_path, outfile]) == 0)
        case null:
            let command = split(compiler_args.valgrind)
            command.push(exe_path)
            command.push_all(program_args)

            let result = run(command, compiler_args.verbose)
            print("Program exited with status {result}")
            assert(result == 0)
