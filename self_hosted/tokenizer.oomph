func starts_with_any(Str s, List[Str] prefixes) -> Optional[Str]:
    foreach prefix of prefixes:
        if s.starts_with(prefix):
            return prefix
    return null

func get_simple_identifier(Str code) -> Optional[Str]:
    let first_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_"
    let continue_chars = first_chars + "1234567890"

    let match = starts_with_any(code, first_chars.split(""))
    if match == null:
        return null

    let result = match.get()
    while true:
        let match = starts_with_any(code.remove_prefix(result).get(), continue_chars.split(""))
        if match == null:
            return result
        result = result + match.get()

func get_identifier(Str code) -> Optional[Str]:
    switch get_simple_identifier(code):
        case Str s:
            let remaining = code.remove_prefix(s).get()
            if remaining.starts_with("::"):
                # TODO: better error handling for foo::123
                return s + "::" + get_simple_identifier(remaining.remove_prefix("::").get()).get()
            return s
        case *:
            return null

# TODO: enums
# TODO: keep track of line numbers
export class Token(Str type, Str value):
    meth matches(Str type, Str value) -> Bool:
        return self.type == type and self.value == value

func get_int(Str code) -> Str:
    let result = ""
    while true:
        # TODO: this is ugly
        let did_something = false
        for let digit = 0; digit <= 9; digit = digit + 1:
            if code.remove_prefix(result).get().starts_with(digit.to_string()):
                result = result + digit.to_string()
                did_something = true
        if not did_something:
            return result

func extract_string(Str code, Str quotes) -> Str:
    let result = quotes

    while true:
        if code.remove_prefix(result).get().starts_with(quotes):
            return result + quotes

        # Ignore backslash-escaped quotes, and actually, any backslash-escaped char
        if code.remove_prefix(result).get().starts_with("\\"):
            result = result + "\\"

        if code == result:
            print("string does not terminate: {code}")
            assert(false)  # TODO: error
        result = result + code.remove_prefix(result).get().split("").first()
        if code == result:
            print("string does not terminate: {code}")
            assert(false)  # TODO: error

func get_prefix_spaces(Str string) -> Str:
    let result = 0
    while string.starts_with(" "):
        result = result + 1
        string = string.remove_prefix(" ").get()
    return " ".repeat(result)

func raw_tokenize(Str code) -> List[Token]:
    if not code.ends_with("\n"):
        code = code + "\n"

    let op_list = [
        # Longer ops need to be first, otherwise -> is detected as - and > separate
        "->", "==", "!=", "<=", ">=",
        "<", ">",
        ";", ",", ".", ":",
        "(", ")", "[", "]",
        "+", "-", "*", "/",
        "=", "\n",
    ]
    let keyword_list = [
        "let", "import", "as", "export", "func", "meth", "class", "union", "switch", "case",
        "auto", "generic", "new", "return", "pass", "mod", "and", "or", "not", "in",
        "if", "elif", "else", "while", "for", "foreach", "of", "continue", "break",
    ]

    let result = []
    while code != "":
        let id = get_identifier(code)
        let op = starts_with_any(code, op_list)
        let int_value = get_int(code)

        if id != null:
            if id.get() in keyword_list:
                let token = new Token("keyword", id.get())
            else:
                token = new Token("id", id.get())

        elif op != null:
            token = new Token("op", op.get())

        elif int_value != "":
            let remaining = code.remove_prefix(int_value).get()
            if remaining.starts_with("."):
                # this may set digit_after_dot to null
                let digit_after_dot = starts_with_any(
                    remaining.remove_prefix(".").get(),
                    "0123456789".split(""))
            else:
                digit_after_dot = null

            if digit_after_dot == null:
                # int
                assert(int_value == "0" or not int_value.starts_with("0"))  # TODO: error
                token = new Token("int", int_value)
            else:
                # float
                let float_value = int_value + "." + get_int(remaining.remove_prefix(".").get())
                token = new Token("float", float_value)

        elif code.starts_with(" "):
            if result != [] and result.last().matches("op", "\n"):
                # Space after newline: indentation
                let spaces = get_prefix_spaces(code)
                let after_indent = code.remove_prefix(spaces).get()
                if after_indent.starts_with("#") or after_indent.starts_with("\n"):
                    # This line doesn't actually contain any code, ignore the indent
                    code = after_indent
                    continue
                token = new Token("indent", spaces)
            else:
                # Space to be ignored
                # TODO: error for indents in beginning of file
                code = code.remove_prefix(" ").get()
                continue

        elif code.starts_with("#"):
            code = code.remove_prefix(code.split("\n").first()).get()
            continue

        elif code.starts_with("\"\"\""):
            let content = extract_string(code, "\"\"\"")
            token = new Token("multiline_string", content)

        elif code.starts_with("\""):
            let content = extract_string(code.split("\n").first(), "\"")
            token = new Token("oneline_string", content)

        else:
            print(result)
            print("Invalid syntax: {code}")
            assert(false)  # TODO: error

        code = code.remove_prefix(token.value).get()
        result.push(token)

    return result

func ignore_whitespace_in_parens(List[Token] tokens) -> List[Token]:
    let result = []
    let paren_stack = []

    foreach token of tokens:
        if token.matches("op", "("):
            paren_stack.push(")")
        elif token.matches("op", "["):
            paren_stack.push("]")
        elif token.matches("op", ")") or token.matches("op", "]"):
            assert(paren_stack.pop() == token.value)

        if paren_stack == [] or token.value.trim() != "":
            result.push(token)

    return result

func combine_not_in(List[Token] tokens) -> List[Token]:
    let result = []
    for let i = 0; i < tokens.length(); :
        if i+1 < tokens.length() and tokens.get(i).matches("keyword", "not") and tokens.get(i+1).matches("keyword", "in"):
            result.push(new Token("keyword", "not in"))
            i = i + 2
        else:
            result.push(tokens.get(i))
            i = i + 1
    return result

func skip_newlines(List[Token] tokens):
    while tokens != [] and tokens.last().matches("op", "\n"):
        tokens.pop()

func clean_newlines(List[Token] tokens) -> List[Token]:
    let result = []
    tokens = tokens.reversed()

    skip_newlines(tokens)
    while tokens != []:
        let token = tokens.pop()
        result.push(token)
        if token.matches("op", "\n") or token.type == "begin_block" or token.type == "end_block":
            skip_newlines(tokens)

    return result

func find_blocks(List[Token] tokens) -> List[Token]:
    let indent_level = 0
    let result = []
    tokens = tokens.reversed()

    while tokens != []:
        let head = tokens.reversed().slice(0, 3)
        if (head.length() == 3
        and head.get(0).matches("op", ":")
        and head.get(1).matches("op", "\n")
        and head.get(2).type == "indent"):
            indent_level = indent_level + 1
            assert(head.get(2).value == " ".repeat(4*indent_level))  # TODO: error
            result.push(new Token("begin_block", ":"))
            tokens.pop()
            tokens.pop()
            tokens.pop()
            continue

        result.push(head.first())
        tokens.pop()

        if head.first().matches("op", "\n"):
            if head.length() >= 2 and head.get(1).type == "indent":
                let new_level = (head.get(1).value.length() / 4).round()
                assert(head.get(1).value == " ".repeat(4*new_level))  # TODO: error
                tokens.pop()   # skip indent token
            else:
                new_level = 0

            assert(new_level <= indent_level)   # TODO: error
            for ; new_level != indent_level; indent_level = indent_level - 1:
                result.push(new Token("end_block", ""))

    return result

export func tokenize(Str code) -> List[Token]:
    return clean_newlines(
        find_blocks(
        clean_newlines(
        combine_not_in(
        ignore_whitespace_in_parens(
        raw_tokenize(code))))))
