import "location.oomph" as location
typedef Location = location::Location

export typedef Type = AutoType | BasicType | FunctionType | UnionType

export class AutoType(Int id)

# TODO: better way to make constants similar to null, true, false
export class NoReturn()

# FIXME: missing equals method
export class FunctionType(List[Type] argtypes, Type | null | NoReturn returntype)

# TODO: mappings
export class Method(Str name, FunctionType functype)
export class Member(Str name, Type type)

export class Generic(Str name)
export class GenericSource(Generic generik, List[Type] args):
    # TODO: some kind of handy way to say "do equality checks by value"
    # TODO: this equals method still needed?
    meth equals(GenericSource other) -> Bool:
        return self.generik == other.generik and self.args == other.args

export class BasicType(
    Str name,
    Bool refcounted,
    List[Method] methods,
    List[Member] members,
    List[Type] | null constructor_argtypes,
    GenericSource | null generic_source,
    Str | null definition_path,  # null for builtin
    List[Str] methods_to_create,
):
    # Helps with reference cycles
    meth to_string() -> Str:
        return "<BasicType: {self.name}>"

    meth equals(BasicType other) -> Bool:
        if self.generic_source == null and other.generic_source == null:
            return (self.name == other.name and self.definition_path == other.definition_path)
        else:
            return (self.generic_source == other.generic_source)


export class UnionType(
    List[Type] type_members,
    Str | null custom_name,
    Builtins builtins,  # TODO: this sucks
):
    # Helps with reference cycles
    meth to_string() -> Str:
        return "<UnionType {type_name(self)}: custom_name={self.custom_name}>"

    meth equals(UnionType other) -> Bool:
        return self.type_members == other.type_members


export func make_union(
    Builtins builtins,
    List[Type] type_members,
    Location | null location,
) -> UnionType:
    let flattened = []
    foreach member of type_members:
        switch member:
            case UnionType union:
                flattened.push_all(union.type_members)
            case *:
                flattened.push(member)

    assert(flattened.length() >= 2)

    # check no duplicates
    for let i = 0; i < flattened.length(); i = i+1:
        if flattened.get(i) in flattened.slice(0, i):
            (location as not null).error(
                "repeated union member '{type_name(flattened.get(i))}'"
            )

    # FIXME: sort the type members consistently

    return new UnionType(flattened, null, builtins)


export func is_refcounted(Type type) -> Bool:
    switch type:
        case AutoType _:
            assert(false)
        case BasicType basictype:
            return basictype.refcounted
        case FunctionType _:
            return false
        case UnionType _:
            return true


export func get_constructor_argtypes(Type type) -> List[Type] | null:
    switch type:
        case AutoType _:
            assert(false)
        case BasicType basictype:
            return basictype.constructor_argtypes
        case FunctionType | UnionType _:
            return null

export func type_name(Type type) -> Str:
    switch type:
        case AutoType autotype:
            return "auto{autotype.id}"
        case BasicType basic:
            return basic.name
        case FunctionType functype:
            return "<function type>"  # TODO
        case UnionType union:
            if union.custom_name == null:
                return "(" + [
                    foreach t of union.type_members: type_name(t)
                ].join(" | ") + ")"
            return union.custom_name as not null

export func type_id_string(Type type) -> Str:
    switch type:
        case AutoType _:
            assert(false)
        case BasicType basictype:
            if basictype.generic_source == null:
                return basictype.name + "@" + basictype.definition_path.to_string()
            let source = basictype.generic_source as not null
            return source.generik.name + [foreach arg of source.args: type_id_string(arg)].join(",")
        case UnionType union:
            return [foreach m of union.type_members: type_id_string(m)].join("|")
        case FunctionType _:
            assert(false)   # TODO

export func get_generic_source(Type type) -> GenericSource | null:
    switch type:
        case AutoType _:
            assert(false)
        case BasicType basictype:
            return basictype.generic_source
        case FunctionType | UnionType _:
            return null


export typedef Variable = BuiltinVariable | FileVariable | LocalVariable
export class BuiltinVariable(Str name, Type type)
export class FileVariable(Str name, Type type)
export class LocalVariable(Type type, Int id, Location location)

# TODO: this sucks
export func var_type(Variable var) -> Type:
    switch var:
        case BuiltinVariable builtin_var:
            return builtin_var.type
        case FileVariable file_var:
            return file_var.type
        case LocalVariable local_var:
            return local_var.type


# TODO: global (but const) variables
export class Builtins(
    Type BOOL,
    Type FLOAT,
    Type INT,
    Type NULL_TYPE,
    Type STR,
    Generic LIST,
    Generic MAPPING,
    Generic MAPPING_ITEM,
    List[BuiltinVariable] visible_vars,
    List[BuiltinVariable] hidden_vars,
    List[BasicType] cleanup_list,
):
    meth destroy():
        # get rid of reference cycles
        foreach type of self.cleanup_list:
            # TODO: 'thing.methods = []' doesn't work
            type.methods = new List[Method]()
            type.members = new List[Member]()
            type.constructor_argtypes = null as List[Type] | null

    meth get_visible_var(Str name) -> BuiltinVariable:
        foreach var of self.visible_vars:
            if var.name == name:
                return var
        print("variable {name} not found")
        assert(false)

    meth get_hidden_var(Str name) -> BuiltinVariable:
        foreach var of self.hidden_vars:
            if var.name == name:
                return var
        print("INTERNAL ERROR: hidden variable {name} not found")
        assert(false)

    meth get_builtin_types() -> List[Type]:
        return [self.BOOL, self.FLOAT, self.INT, self.NULL_TYPE, self.STR]

    meth get_builtin_generics() -> List[Generic]:
        return [self.LIST, self.MAPPING]

    # TODO: this is in a weird place
    meth generic2type(Generic generik, List[Type] args, Location | null location) -> Type:
        let source = new GenericSource(generik, args)
        let result = new BasicType(
            generik.name + "[" + [foreach arg of args: type_name(arg)].join(", ") + "]",
            true,
            [],
            [],
            new List[Type](),  # FIXME: [] doesn't work
            new GenericSource(generik, args),
            null,
            [],
        )
        let r = result as Type  # TODO: get rid of this

        if generik == self.LIST:
            assert(args.length() == 1)   # TODO: error
            let arg = args.first()
            result.methods.push_all([
                new Method("__contains", new FunctionType([r, arg], self.BOOL)),  # TODO: hide?
                new Method("copy", new FunctionType([r], r)),
                new Method("delete_at_index", new FunctionType([r, self.INT], arg)),
                new Method("delete_first", new FunctionType([r, arg], null)),
                new Method("delete_last", new FunctionType([r, arg], null)),
                new Method("delete_only", new FunctionType([r, arg], null)),
                new Method("delete_slice", new FunctionType([r, self.INT, self.INT], r)),
                new Method("ends_with", new FunctionType([r, r], self.BOOL)),
                new Method("equals", new FunctionType([r, r], self.BOOL)),
                new Method("find_first", new FunctionType([r, arg], self.INT)),
                new Method("find_last", new FunctionType([r, arg], self.INT)),
                new Method("find_only", new FunctionType([r, arg], self.INT)),
                new Method("first", new FunctionType([r], arg)),
                new Method("get", new FunctionType([r, self.INT], arg)),
                new Method("insert", new FunctionType([r, self.INT, arg], null)),
                new Method("last", new FunctionType([r], arg)),
                new Method("length", new FunctionType([r], self.INT)),
                new Method("pop", new FunctionType([r], arg)),
                new Method("push", new FunctionType([r, arg], null)),
                new Method("push_all", new FunctionType([r, r], null)),
                new Method("reversed", new FunctionType([r], r)),
                new Method("set", new FunctionType([r, self.INT, arg], arg)),
                new Method("slice", new FunctionType([r, self.INT, self.INT], r)),
                new Method("starts_with", new FunctionType([r, r], self.BOOL)),
                new Method("to_string", new FunctionType([r], self.STR)),
                # TODO: this is only for strings, but List[auto] may become List[Str] later
                # if arg is STR:
                new Method("join", new FunctionType([r, self.STR], self.STR)),
            ])
        elif generik == self.MAPPING:
            assert(args.length() == 2)   # TODO: error
            let keytype = args.first()
            let valtype = args.last()
            if "hash" not in [foreach m of get_methods(keytype, self): m.name]:
                (location as not null).error(
                    "mapping key type must be hashable, but "
                    + "{type_name(keytype)} doesn't have a .hash() method"
                )
            let itemlist = self.generic2type(
                self.LIST, [self.generic2type(self.MAPPING_ITEM, args, location)], location
            )

            result.methods.push_all([
                new Method("copy", new FunctionType([r], r)),
                new Method("delete", new FunctionType([r, keytype], null)),
                new Method("equals", new FunctionType([r, r], self.BOOL)),
                new Method("get", new FunctionType([r, keytype], valtype)),
                new Method("has_key", new FunctionType([r, keytype], self.BOOL)),
                new Method("items", new FunctionType([r], itemlist)),
                new Method("keys", new FunctionType([r], self.generic2type(self.LIST, [keytype], location))),
                new Method("length", new FunctionType([r], self.INT)),
                new Method("set", new FunctionType([r, keytype, valtype], null)),
                new Method("to_string", new FunctionType([r], self.STR)),
                new Method("values", new FunctionType([r], self.generic2type(self.LIST, [valtype], location))),
            ])
        elif generik == self.MAPPING_ITEM:
            assert(args.length() == 2)
            let keytype = args.first()
            let valtype = args.last()
            result.members.push(new Member("key", keytype))
            result.members.push(new Member("value", valtype))
            result.methods.push_all([
                new Method("equals", new FunctionType([r, r], self.BOOL)),
                new Method("to_string", new FunctionType([r], self.STR)),
            ])
        else:
            assert(false)

        self.cleanup_list.push(result)
        return result


# TODO: custom constructors
export func create_builtins() -> Builtins:
    # Methods are empty at first to prevent reference cycles
    let BOOL = new BasicType("Bool", false, [], [], null, null, null, []) as Type
    let FLOAT = new BasicType("Float", false, [], [], null, null, null, []) as Type
    let INT = new BasicType("Int", false, [], [], null, null, null, []) as Type
    let NULL_TYPE = new BasicType("null", false, [], [], null, null, null, []) as Type
    let STR = new BasicType("Str", true, [], [], null, null, null, []) as Type

    let LIST = new Generic("List")
    let MAPPING = new Generic("Mapping")
    let MAPPING_ITEM = new Generic("MappingItem")

    # These variables are not exposed in oomph
    let hidden_vars = [
        new BuiltinVariable("bool_eq", new FunctionType([BOOL, BOOL], BOOL)),
        new BuiltinVariable("bool_not", new FunctionType([BOOL], BOOL)),
        new BuiltinVariable("float_add", new FunctionType([FLOAT, FLOAT], FLOAT)),
        new BuiltinVariable("float_div", new FunctionType([FLOAT, FLOAT], FLOAT)),
        new BuiltinVariable("float_eq", new FunctionType([FLOAT, FLOAT], BOOL)),
        new BuiltinVariable("float_gt", new FunctionType([FLOAT, FLOAT], BOOL)),
        new BuiltinVariable("float_mod", new FunctionType([FLOAT, FLOAT], FLOAT)),
        new BuiltinVariable("float_mul", new FunctionType([FLOAT, FLOAT], FLOAT)),
        new BuiltinVariable("float_neg", new FunctionType([FLOAT], FLOAT)),
        new BuiltinVariable("float_sub", new FunctionType([FLOAT, FLOAT], FLOAT)),
        new BuiltinVariable("int2float", new FunctionType([INT], FLOAT)),
        new BuiltinVariable("int_add", new FunctionType([INT, INT], INT)),
        new BuiltinVariable("int_eq", new FunctionType([INT, INT], BOOL)),
        new BuiltinVariable("int_gt", new FunctionType([INT, INT], BOOL)),
        new BuiltinVariable("int_mod", new FunctionType([INT, INT], INT)),
        new BuiltinVariable("int_mul", new FunctionType([INT, INT], INT)),
        new BuiltinVariable("int_neg", new FunctionType([INT], INT)),
        new BuiltinVariable("int_sub", new FunctionType([INT, INT], INT)),
        new BuiltinVariable("string_concat", new FunctionType([STR, STR], STR)),
        new BuiltinVariable("string_eq", new FunctionType([STR, STR], BOOL)),
    ]

    let visible_vars = []
    let result = new Builtins(
        BOOL, FLOAT, INT, NULL_TYPE, STR,
        LIST, MAPPING, MAPPING_ITEM,
        visible_vars, hidden_vars,
        [],
    )
    result.cleanup_list.push_all([foreach t of result.get_builtin_types(): t as BasicType])

    visible_vars.push_all([
        new BuiltinVariable("__argv_count", new FunctionType([], INT)),
        new BuiltinVariable("__argv_get", new FunctionType([INT], STR)),
        new BuiltinVariable("__exit", new FunctionType([INT], new NoReturn())),
        new BuiltinVariable("__get_first_char", new FunctionType([STR], STR)),
        new BuiltinVariable("__get_utf8_byte", new FunctionType([STR, INT], INT)),
        new BuiltinVariable("__hash", new FunctionType([STR, STR], STR)),
        new BuiltinVariable("__io_delete_at_exit", new FunctionType([STR], null)),
        new BuiltinVariable("__io_mkdir", new FunctionType([STR], null)),
        new BuiltinVariable("__io_read_file", new FunctionType([STR], STR)),
        new BuiltinVariable("__io_write_file", new FunctionType([STR, STR], null)),
        new BuiltinVariable("__remove_prefix", new FunctionType([STR, STR], STR)),
        new BuiltinVariable("__remove_suffix", new FunctionType([STR, STR], STR)),
        new BuiltinVariable("__run_subprocess", new FunctionType([result.generic2type(LIST, [STR], null)], INT)),
        new BuiltinVariable("__slice_until_substring", new FunctionType([STR, STR], STR)),
        new BuiltinVariable("__utf8_len", new FunctionType([STR], INT)),
        new BuiltinVariable("assert", new FunctionType([BOOL, STR, INT], null)),
        new BuiltinVariable("false", BOOL),
        new BuiltinVariable("null", NULL_TYPE),
        new BuiltinVariable("print", new FunctionType([STR], null)),
        new BuiltinVariable("true", BOOL),
    ])

    (FLOAT as BasicType).methods.push_all([
        new Method("ceil", new FunctionType([FLOAT], INT)),
        new Method("equals", new FunctionType([FLOAT, FLOAT], BOOL)),
        new Method("floor", new FunctionType([FLOAT], INT)),
        new Method("round", new FunctionType([FLOAT], INT)),
        new Method("to_string", new FunctionType([FLOAT], STR)),
        new Method("truncate", new FunctionType([FLOAT], INT)),
    ])

    (STR as BasicType).methods.push_all([
        new Method("__contains", new FunctionType([STR, STR], BOOL)),
        new Method("center_pad", new FunctionType([STR, INT, STR], STR)),
        new Method("count", new FunctionType([STR, STR], INT)),
        new Method("ends_with", new FunctionType([STR, STR], BOOL)),
        new Method("equals", new FunctionType([STR, STR], BOOL)),
        new Method("get_utf8", new FunctionType([STR], result.generic2type(LIST, [INT], null))),
        new Method("left_pad", new FunctionType([STR, INT, STR], STR)),
        new Method("left_trim", new FunctionType([STR], STR)),
        new Method("length", new FunctionType([STR], INT)),
        new Method("hash", new FunctionType([STR], INT)),
        new Method("remove_prefix", new FunctionType([STR, STR], STR)),
        new Method("remove_suffix", new FunctionType([STR, STR], STR)),
        new Method("repeat", new FunctionType([STR, INT], STR)),
        new Method("replace", new FunctionType([STR, STR, STR], STR)),
        new Method("right_pad", new FunctionType([STR, INT, STR], STR)),
        new Method("right_trim", new FunctionType([STR], STR)),
        new Method("split", new FunctionType([STR, STR], result.generic2type(LIST, [STR], null))),
        new Method("starts_with", new FunctionType([STR, STR], BOOL)),
        new Method("to_float", new FunctionType([STR], FLOAT)),
        new Method("to_int", new FunctionType([STR], INT)),
        new Method("to_string", new FunctionType([STR], STR)),  # does nothing
        new Method("trim", new FunctionType([STR], STR)),
    ])

    (BOOL as BasicType).methods.push_all([
        new Method("equals", new FunctionType([BOOL, BOOL], BOOL)),
        new Method("hash", new FunctionType([BOOL], INT)),
        new Method("to_string", new FunctionType([BOOL], STR)),
    ])

    (INT as BasicType).methods.push_all([
        new Method("equals", new FunctionType([INT, INT], BOOL)),
        new Method("hash", new FunctionType([INT], INT)),
        new Method("to_string", new FunctionType([INT], STR)),
    ])

    (NULL_TYPE as BasicType).methods.push_all([
        new Method("equals", new FunctionType([NULL_TYPE, NULL_TYPE], BOOL)),
        new Method("hash", new FunctionType([NULL_TYPE], INT)),
        new Method("to_string", new FunctionType([NULL_TYPE], STR)),
    ])

    return result

# TODO: stdlib?
func all(List[Bool] things) -> Bool:
    foreach thing of things:
        if not thing:
            return false
    return true

export func get_methods(Type type, Builtins builtins) -> List[Method]:
    switch type:
        case AutoType _:
            assert(false)

        case BasicType basictype:
            let result = basictype.methods.copy()
            foreach addition of basictype.methods_to_create:
                if addition == "to_string":
                    result.push(new Method("to_string", new FunctionType([type], builtins.STR)))
                elif addition == "equals":
                    result.push(new Method("equals", new FunctionType([type, type], builtins.BOOL)))
                elif addition == "hash":
                    result.push(new Method("hash", new FunctionType([type], builtins.INT)))
                else:
                    assert(false)
            return result

        case FunctionType _:
            return []

        case UnionType union:
            let result = [
                new Method("equals", new FunctionType([type, type], builtins.BOOL)),
                new Method("to_string", new FunctionType([type], builtins.STR)),
            ]
            if all([
                foreach t of union.type_members:
                    "hash" in [foreach m of get_methods(t, builtins): m.name]
            ]):
                result.push(new Method("hash", new FunctionType([type, type], builtins.INT)))
            return result

export func get_method(Type type, Str name, Builtins builtins) -> FunctionType:
    foreach method of get_methods(type, builtins):
        if method.name == name:
            return method.functype

    print("type {type_name(type)} has no method named {name}")
    assert(false)   # TODO: error

export func get_member(Type type, Str name) -> Type:
    switch type:
        case AutoType a:
            assert(false)
        case BasicType basictype:
            let members = basictype.members
        case *:
            members = []

    foreach member of members:
        if member.name == name:
            return member.type

    print("type {type_name(type)} has no member named {name}")
    assert(false)   # TODO: error


export typedef Instruction = (
    ConstructorCall
    | DecRef
    | FloatConstant
    | FunctionCall
    | GetAttribute
    | GetFromUnion
    | GotoIf
    | GotoLabel
    | IncRef
    | InstantiateUnion
    | IntConstant
    | MethodCall
    | Panic
    | Return
    | SetAttribute
    | StringConstant
    | UnSet
    | UnionMemberCheck
    | VarCpy
)
export class ConstructorCall(LocalVariable result, List[LocalVariable] args)
export class DecRef(LocalVariable var)
export class FloatConstant(Str value, LocalVariable var)
export class FunctionCall(Variable function, List[LocalVariable] args, LocalVariable | null result)
export class GetAttribute(LocalVariable obj, LocalVariable attribute_var, Str attribute)
export class GetFromUnion(LocalVariable result, LocalVariable union_var)
export class GotoLabel(Int id)
export class GotoIf(GotoLabel label, LocalVariable cond)
export class IncRef(LocalVariable var)
export class InstantiateUnion(LocalVariable result, LocalVariable value)
export class IntConstant(Int value, LocalVariable var)
export class MethodCall(LocalVariable obj, Str method_name, List[LocalVariable] args, LocalVariable | null result, Location location)
export class Panic(Str message, Location location)
export class Return(LocalVariable | null value)
export class SetAttribute(LocalVariable obj, Str attribute, LocalVariable attribute_var)
export class StringConstant(Str value, LocalVariable var)
export class UnSet(LocalVariable var)
export class UnionMemberCheck(LocalVariable result, LocalVariable union_var, Type member_type)
export class VarCpy(LocalVariable dest, Variable source)  # same argument order as memcpy

export typedef ToplevelDeclaration = FuncDef | MethodDef
export class FuncDef(FileVariable var, List[LocalVariable] argvars, List[Instruction] body)
export class MethodDef(Str name, FunctionType type, List[LocalVariable] argvars, List[Instruction] body)

# Symbol represents anything that might need to be shared between different .c files
export typedef SymbolValue = FileVariable | Type
export class Symbol(Str path, Str name, SymbolValue value)
