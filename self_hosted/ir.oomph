export union Type:
    AutoType
    BasicType
    FunctionType
    UnionType

export class AutoType(Int id)
export class FunctionType(List[Type] argtypes, Optional[Type] returntype)

# TODO: mappings
export class Method(Str name, FunctionType functype)
export class Member(Str name, Type type)
export class BasicType(Str name, Bool refcounted, List[Method] methods, List[Member] members)

# type_members can be temporarily null, allows nested unions
export class UnionType(Str name, Optional[List[Type]] type_members)

export func type_name(Type type) -> Str:
    switch type:
        case AutoType autotype:
            return "auto{autotype.id}"
        case BasicType basic:
            return basic.name
        case FunctionType functype:
            return "<function type>"
        case UnionType uniontype:
            return uniontype.name

export class BuiltinVariable(Str name, Type type)
export class FileVariable(Str name, Type type)
export class LocalVariable(Type type, Int id)
export union Variable:
    BuiltinVariable
    FileVariable
    LocalVariable


# TODO: global (but const) variables
export class Builtins(
    Type BOOL,
    Type FLOAT,
    Type INT,
    Type NULL_TYPE,
    Type STR,
    List[BuiltinVariable] visible_vars,
    List[BuiltinVariable] hidden_vars,
    List[Method] methods,  # to prevent reference cycles
):

    meth get_visible_var(Str name) -> BuiltinVariable:
        foreach var of self.visible_vars:
            if var.name == name:
                return var
        print("variable {name} not found")
        assert(false)

    meth get_hidden_var(Str name) -> BuiltinVariable:
        foreach var of self.hidden_vars:
            if var.name == name:
                return var
        print("INTERNAL ERROR: hidden variable {name} not found")
        assert(false)


# TODO: custom constructors
export func create_builtins() -> Builtins:
    # TODO: these cause reference cycles, do something about it
    let bool_methods = []
    let float_methods = []
    let int_methods = []
    let null_methods = []
    let str_methods = []

    let BOOL = new Type(new BasicType("Bool", false, bool_methods, []))
    let FLOAT = new Type(new BasicType("Float", false, float_methods, []))
    let INT = new Type(new BasicType("Int", false, int_methods, []))
    let NULL_TYPE = new Type(new BasicType("Bool", false, null_methods, []))
    let STR = new Type(new BasicType("Str", true, str_methods, []))

    let visible_vars = [
        new BuiltinVariable("__argv_count", new FunctionType([], INT)),
        new BuiltinVariable("__argv_get", new FunctionType([INT], STR)),
        new BuiltinVariable("__io_mkdir", new FunctionType([STR], null)),
        new BuiltinVariable("__io_read_file", new FunctionType([STR], STR)),
        new BuiltinVariable("__io_write_file", new FunctionType([STR, STR], null)),
        new BuiltinVariable("__remove_prefix", new FunctionType([STR, STR], STR)),
        new BuiltinVariable("__remove_suffix", new FunctionType([STR, STR], STR)),
        new BuiltinVariable("__slice_until_substring", new FunctionType([STR, STR], STR)),
        new BuiltinVariable("__string_get_first_char", new FunctionType([STR], STR)),
        new BuiltinVariable("__string_get_utf8_byte", new FunctionType([STR, INT], INT)),
        #new BuiltinVariable("__run_subprocess", new FunctionType([LIST.get_type(STR)], INT)),
        new BuiltinVariable("assert", new FunctionType([BOOL, STR, INT], null)),
        new BuiltinVariable("false", BOOL),
        new BuiltinVariable("null", NULL_TYPE),
        new BuiltinVariable("print", new FunctionType([STR], null)),
        new BuiltinVariable("true", BOOL),
    ]

    # These variables are not exposed in oomph
    let hidden_vars = [
        new BuiltinVariable("bool_eq", new FunctionType([BOOL, BOOL], BOOL)),
        new BuiltinVariable("bool_not", new FunctionType([BOOL], BOOL)),
        new BuiltinVariable("float_add", new FunctionType([FLOAT, FLOAT], FLOAT)),
        new BuiltinVariable("float_div", new FunctionType([FLOAT, FLOAT], FLOAT)),
        new BuiltinVariable("float_eq", new FunctionType([FLOAT, FLOAT], BOOL)),
        new BuiltinVariable("float_gt", new FunctionType([FLOAT, FLOAT], BOOL)),
        new BuiltinVariable("float_mod", new FunctionType([FLOAT, FLOAT], FLOAT)),
        new BuiltinVariable("float_mul", new FunctionType([FLOAT, FLOAT], FLOAT)),
        new BuiltinVariable("float_neg", new FunctionType([FLOAT], FLOAT)),
        new BuiltinVariable("float_sub", new FunctionType([FLOAT, FLOAT], FLOAT)),
        new BuiltinVariable("int2float", new FunctionType([INT], FLOAT)),
        new BuiltinVariable("int_add", new FunctionType([INT, INT], INT)),
        new BuiltinVariable("int_eq", new FunctionType([INT, INT], BOOL)),
        new BuiltinVariable("int_gt", new FunctionType([INT, INT], BOOL)),
        new BuiltinVariable("int_mod", new FunctionType([INT, INT], INT)),
        new BuiltinVariable("int_mul", new FunctionType([INT, INT], INT)),
        new BuiltinVariable("int_neg", new FunctionType([INT], INT)),
        new BuiltinVariable("int_sub", new FunctionType([INT, INT], INT)),
        new BuiltinVariable("string_concat", new FunctionType([STR, STR], STR)),
        new BuiltinVariable("string_eq", new FunctionType([STR, STR], BOOL)),
    ]

    let methods = [
        new Method("ceil", new FunctionType([FLOAT], INT)),
        new Method("center_pad", new FunctionType([STR, INT, STR], STR)),
        new Method("contains", new FunctionType([STR, STR], BOOL)),
        new Method("count", new FunctionType([STR, STR], INT)),
        new Method("ends_with", new FunctionType([STR, STR], BOOL)),
        new Method("equals", new FunctionType([BOOL, BOOL], BOOL)),
        new Method("equals", new FunctionType([FLOAT, FLOAT], BOOL)),
        new Method("equals", new FunctionType([INT, INT], BOOL)),
        new Method("equals", new FunctionType([STR, STR], BOOL)),
        new Method("floor", new FunctionType([FLOAT], INT)),
        #new Method("get_utf8", new FunctionType([STR], LIST.get_type(INT))),
        new Method("left_pad", new FunctionType([STR, INT, STR], STR)),
        new Method("left_trim", new FunctionType([STR], STR)),
        new Method("length", new FunctionType([STR], INT)),
        new Method("remove_prefix", new FunctionType([STR, STR], STR)),
        new Method("remove_suffix", new FunctionType([STR, STR], STR)),
        new Method("repeat", new FunctionType([STR, INT], STR)),
        new Method("replace", new FunctionType([STR, STR, STR], STR)),
        new Method("right_pad", new FunctionType([STR, INT, STR], STR)),
        new Method("right_trim", new FunctionType([STR], STR)),
        new Method("round", new FunctionType([FLOAT], INT)),
        #new Method("split", new FunctionType([STR, STR], LIST.get_type(STR))),
        new Method("starts_with", new FunctionType([STR, STR], BOOL)),
        new Method("to_float", new FunctionType([STR], FLOAT)),
        new Method("to_int", new FunctionType([STR], INT)),
        new Method("to_string", new FunctionType([BOOL], STR)),
        new Method("to_string", new FunctionType([FLOAT], STR)),
        new Method("to_string", new FunctionType([INT], STR)),
        new Method("to_string", new FunctionType([NULL_TYPE], STR)),
        new Method("to_string", new FunctionType([STR], STR)),  # does nothing
        new Method("trim", new FunctionType([STR], STR)),
        new Method("truncate", new FunctionType([FLOAT], INT)),
    ]

    return new Builtins(BOOL, FLOAT, INT, NULL_TYPE, STR, visible_vars, hidden_vars, methods)


export func get_method(Type type, Str name, Builtins builtins) -> FunctionType:
    foreach method of builtins.methods:
        if method.functype.argtypes.first() == type and method.name == name:
            return method.functype

    switch type:
        case AutoType a:
            assert(false)
        case BasicType basictype:
            let methods = basictype.methods
        case FunctionType functype:
            methods = []
        case UnionType uniontype:
            methods = [
                new Method("equals", new FunctionType([type, type], builtins.BOOL)),
                new Method("to_string", new FunctionType([type], builtins.STR)),
            ]

    foreach method of methods:
        if method.name == name:
            return method.functype

    print("type {type_name(type)} has no method named {name}")
    assert(false)   # TODO: error


export union Instruction:
    FloatConstant
    FunctionCall
    GotoIf
    GotoLabel
    IntConstant
    IntToFloat
    MethodCall
    StringConstant
    VarCpy

export class FloatConstant(Str value, LocalVariable var)
export class FunctionCall(BuiltinVariable function, List[LocalVariable] args, Optional[LocalVariable] result_var)
export class GotoLabel(Int id)
export class GotoIf(GotoLabel label, LocalVariable condition)
export class IntConstant(Int value, LocalVariable var)
export class IntToFloat(LocalVariable int_var, LocalVariable float_var)
export class MethodCall(LocalVariable obj, Str method_name, List[LocalVariable] args, Optional[LocalVariable] result)
export class StringConstant(Str value, LocalVariable var)
export class VarCpy(LocalVariable dest, Variable source)  # same argument order as memcpy

export union ToplevelDeclaration:
    FuncDef
    MethodDef

export class FuncDef(FileVariable var, List[LocalVariable] argvars, List[Instruction] body)
export class MethodDef(Str name, FunctionType type, List[LocalVariable] argvars, List[Instruction] body)

# Symbol represents anything that might need to be shared between different .c files
export union SymbolValue:
    FileVariable
    Type
export class Symbol(Str path, Str name, SymbolValue value)
